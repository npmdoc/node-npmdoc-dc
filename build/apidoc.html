<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://dc-js.github.io/dc.js/"

    >dc (v2.0.2)</a>
</h1>
<h4>A multi-dimensional charting library built to work natively with crossfilter and rendered using d3.js </h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.dc">module dc</a><ol>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan"></span>dc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.</span>crossfilter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.</span>d3</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.</span>shCore</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.dc.crossfilter">module dc.crossfilter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.crossfilter.crossfilter">
            function <span class="apidocSignatureSpan">dc.</span>crossfilter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.dc.d3">module dc.d3</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.ascending">
            function <span class="apidocSignatureSpan">dc.d3.</span>ascending
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.bisect">
            function <span class="apidocSignatureSpan">dc.d3.</span>bisect
            <span class="apidocSignatureSpan">(a, x, lo, hi)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.bisectLeft">
            function <span class="apidocSignatureSpan">dc.d3.</span>bisectLeft
            <span class="apidocSignatureSpan">(a, x, lo, hi)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.bisectRight">
            function <span class="apidocSignatureSpan">dc.d3.</span>bisectRight
            <span class="apidocSignatureSpan">(a, x, lo, hi)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.bisector">
            function <span class="apidocSignatureSpan">dc.d3.</span>bisector
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.color">
            function <span class="apidocSignatureSpan">dc.d3.</span>color
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.csv">
            function <span class="apidocSignatureSpan">dc.d3.</span>csv
            <span class="apidocSignatureSpan">(url, row, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.descending">
            function <span class="apidocSignatureSpan">dc.d3.</span>descending
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.deviation">
            function <span class="apidocSignatureSpan">dc.d3.</span>deviation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.dispatch">
            function <span class="apidocSignatureSpan">dc.d3.</span>dispatch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.dsv">
            function <span class="apidocSignatureSpan">dc.d3.</span>dsv
            <span class="apidocSignatureSpan">(delimiter, mimeType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.ease">
            function <span class="apidocSignatureSpan">dc.d3.</span>ease
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.entries">
            function <span class="apidocSignatureSpan">dc.d3.</span>entries
            <span class="apidocSignatureSpan">(map)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.extent">
            function <span class="apidocSignatureSpan">dc.d3.</span>extent
            <span class="apidocSignatureSpan">(array, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.format">
            function <span class="apidocSignatureSpan">dc.d3.</span>format
            <span class="apidocSignatureSpan">(specifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.formatPrefix">
            function <span class="apidocSignatureSpan">dc.d3.</span>formatPrefix
            <span class="apidocSignatureSpan">(value, precision)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.functor">
            function <span class="apidocSignatureSpan">dc.d3.</span>functor
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.hcl">
            function <span class="apidocSignatureSpan">dc.d3.</span>hcl
            <span class="apidocSignatureSpan">(h, c, l)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.hsl">
            function <span class="apidocSignatureSpan">dc.d3.</span>hsl
            <span class="apidocSignatureSpan">(h, s, l)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.html">
            function <span class="apidocSignatureSpan">dc.d3.</span>html
            <span class="apidocSignatureSpan">(url, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.interpolate">
            function <span class="apidocSignatureSpan">dc.d3.</span>interpolate
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.interpolateArray">
            function <span class="apidocSignatureSpan">dc.d3.</span>interpolateArray
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.interpolateHcl">
            function <span class="apidocSignatureSpan">dc.d3.</span>interpolateHcl
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.interpolateHsl">
            function <span class="apidocSignatureSpan">dc.d3.</span>interpolateHsl
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.interpolateLab">
            function <span class="apidocSignatureSpan">dc.d3.</span>interpolateLab
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.interpolateNumber">
            function <span class="apidocSignatureSpan">dc.d3.</span>interpolateNumber
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.interpolateObject">
            function <span class="apidocSignatureSpan">dc.d3.</span>interpolateObject
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.interpolateRgb">
            function <span class="apidocSignatureSpan">dc.d3.</span>interpolateRgb
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.interpolateRound">
            function <span class="apidocSignatureSpan">dc.d3.</span>interpolateRound
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.interpolateString">
            function <span class="apidocSignatureSpan">dc.d3.</span>interpolateString
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.interpolateTransform">
            function <span class="apidocSignatureSpan">dc.d3.</span>interpolateTransform
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.interpolateZoom">
            function <span class="apidocSignatureSpan">dc.d3.</span>interpolateZoom
            <span class="apidocSignatureSpan">(p0, p1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.json">
            function <span class="apidocSignatureSpan">dc.d3.</span>json
            <span class="apidocSignatureSpan">(url, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.keys">
            function <span class="apidocSignatureSpan">dc.d3.</span>keys
            <span class="apidocSignatureSpan">(map)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.lab">
            function <span class="apidocSignatureSpan">dc.d3.</span>lab
            <span class="apidocSignatureSpan">(l, a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.locale">
            function <span class="apidocSignatureSpan">dc.d3.</span>locale
            <span class="apidocSignatureSpan">(locale)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.map">
            function <span class="apidocSignatureSpan">dc.d3.</span>map
            <span class="apidocSignatureSpan">(object, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.max">
            function <span class="apidocSignatureSpan">dc.d3.</span>max
            <span class="apidocSignatureSpan">(array, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.mean">
            function <span class="apidocSignatureSpan">dc.d3.</span>mean
            <span class="apidocSignatureSpan">(array, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.median">
            function <span class="apidocSignatureSpan">dc.d3.</span>median
            <span class="apidocSignatureSpan">(array, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.merge">
            function <span class="apidocSignatureSpan">dc.d3.</span>merge
            <span class="apidocSignatureSpan">(arrays)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.min">
            function <span class="apidocSignatureSpan">dc.d3.</span>min
            <span class="apidocSignatureSpan">(array, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.mouse">
            function <span class="apidocSignatureSpan">dc.d3.</span>mouse
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.nest">
            function <span class="apidocSignatureSpan">dc.d3.</span>nest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.pairs">
            function <span class="apidocSignatureSpan">dc.d3.</span>pairs
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.permute">
            function <span class="apidocSignatureSpan">dc.d3.</span>permute
            <span class="apidocSignatureSpan">(array, indexes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.quantile">
            function <span class="apidocSignatureSpan">dc.d3.</span>quantile
            <span class="apidocSignatureSpan">(values, p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.range">
            function <span class="apidocSignatureSpan">dc.d3.</span>range
            <span class="apidocSignatureSpan">(start, stop, step)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.rebind">
            function <span class="apidocSignatureSpan">dc.d3.</span>rebind
            <span class="apidocSignatureSpan">(target, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.requote">
            function <span class="apidocSignatureSpan">dc.d3.</span>requote
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.rgb">
            function <span class="apidocSignatureSpan">dc.d3.</span>rgb
            <span class="apidocSignatureSpan">(r, g, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.round">
            function <span class="apidocSignatureSpan">dc.d3.</span>round
            <span class="apidocSignatureSpan">(x, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.select">
            function <span class="apidocSignatureSpan">dc.d3.</span>select
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.selectAll">
            function <span class="apidocSignatureSpan">dc.d3.</span>selectAll
            <span class="apidocSignatureSpan">(nodes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.selection">
            function <span class="apidocSignatureSpan">dc.d3.</span>selection
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.set">
            function <span class="apidocSignatureSpan">dc.d3.</span>set
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.shuffle">
            function <span class="apidocSignatureSpan">dc.d3.</span>shuffle
            <span class="apidocSignatureSpan">(array, i0, i1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.sum">
            function <span class="apidocSignatureSpan">dc.d3.</span>sum
            <span class="apidocSignatureSpan">(array, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.text">
            function <span class="apidocSignatureSpan">dc.d3.</span>text
            <span class="apidocSignatureSpan">(url, mimeType, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.timer">
            function <span class="apidocSignatureSpan">dc.d3.</span>timer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.touch">
            function <span class="apidocSignatureSpan">dc.d3.</span>touch
            <span class="apidocSignatureSpan">(container, touches, identifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.touches">
            function <span class="apidocSignatureSpan">dc.d3.</span>touches
            <span class="apidocSignatureSpan">(container, touches)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.transform">
            function <span class="apidocSignatureSpan">dc.d3.</span>transform
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.transition">
            function <span class="apidocSignatureSpan">dc.d3.</span>transition
            <span class="apidocSignatureSpan">(selection, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.transpose">
            function <span class="apidocSignatureSpan">dc.d3.</span>transpose
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.tsv">
            function <span class="apidocSignatureSpan">dc.d3.</span>tsv
            <span class="apidocSignatureSpan">(url, row, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.values">
            function <span class="apidocSignatureSpan">dc.d3.</span>values
            <span class="apidocSignatureSpan">(map)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.variance">
            function <span class="apidocSignatureSpan">dc.d3.</span>variance
            <span class="apidocSignatureSpan">(array, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.xhr">
            function <span class="apidocSignatureSpan">dc.d3.</span>xhr
            <span class="apidocSignatureSpan">(url, mimeType, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.xml">
            function <span class="apidocSignatureSpan">dc.d3.</span>xml
            <span class="apidocSignatureSpan">(url, mimeType, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.d3.zip">
            function <span class="apidocSignatureSpan">dc.d3.</span>zip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.d3.</span>behavior</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.d3.</span>event</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.d3.</span>geo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.d3.</span>geom</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.d3.</span>interpolators</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.d3.</span>layout</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.d3.</span>ns</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.d3.</span>random</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.d3.</span>scale</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.d3.</span>svg</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.d3.</span>time</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">dc.d3.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.dc.dc">module dc.dc</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">dc.dc.</span>disableTransitions</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.abstractBubbleChart">
            function <span class="apidocSignatureSpan">dc.dc.</span>abstractBubbleChart
            <span class="apidocSignatureSpan">(_chart)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.afterTransition">
            function <span class="apidocSignatureSpan">dc.dc.</span>afterTransition
            <span class="apidocSignatureSpan">(transition, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.barChart">
            function <span class="apidocSignatureSpan">dc.dc.</span>barChart
            <span class="apidocSignatureSpan">(parent, chartGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.baseChart">
            function <span class="apidocSignatureSpan">dc.dc.</span>baseChart
            <span class="apidocSignatureSpan">(_chart)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.baseMixin">
            function <span class="apidocSignatureSpan">dc.dc.</span>baseMixin
            <span class="apidocSignatureSpan">(_chart)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.boxPlot">
            function <span class="apidocSignatureSpan">dc.dc.</span>boxPlot
            <span class="apidocSignatureSpan">(parent, chartGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.bubbleChart">
            function <span class="apidocSignatureSpan">dc.dc.</span>bubbleChart
            <span class="apidocSignatureSpan">(parent, chartGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.bubbleMixin">
            function <span class="apidocSignatureSpan">dc.dc.</span>bubbleMixin
            <span class="apidocSignatureSpan">(_chart)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.bubbleOverlay">
            function <span class="apidocSignatureSpan">dc.dc.</span>bubbleOverlay
            <span class="apidocSignatureSpan">(parent, chartGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.capMixin">
            function <span class="apidocSignatureSpan">dc.dc.</span>capMixin
            <span class="apidocSignatureSpan">(_chart)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.capped">
            function <span class="apidocSignatureSpan">dc.dc.</span>capped
            <span class="apidocSignatureSpan">(_chart)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.colorChart">
            function <span class="apidocSignatureSpan">dc.dc.</span>colorChart
            <span class="apidocSignatureSpan">(_chart)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.colorMixin">
            function <span class="apidocSignatureSpan">dc.dc.</span>colorMixin
            <span class="apidocSignatureSpan">(_chart)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.compositeChart">
            function <span class="apidocSignatureSpan">dc.dc.</span>compositeChart
            <span class="apidocSignatureSpan">(parent, chartGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.coordinateGridChart">
            function <span class="apidocSignatureSpan">dc.dc.</span>coordinateGridChart
            <span class="apidocSignatureSpan">(_chart)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.coordinateGridMixin">
            function <span class="apidocSignatureSpan">dc.dc.</span>coordinateGridMixin
            <span class="apidocSignatureSpan">(_chart)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.crossfilter">
            function <span class="apidocSignatureSpan">dc.dc.</span>crossfilter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.dataCount">
            function <span class="apidocSignatureSpan">dc.dc.</span>dataCount
            <span class="apidocSignatureSpan">(parent, chartGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.dataGrid">
            function <span class="apidocSignatureSpan">dc.dc.</span>dataGrid
            <span class="apidocSignatureSpan">(parent, chartGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.dataTable">
            function <span class="apidocSignatureSpan">dc.dc.</span>dataTable
            <span class="apidocSignatureSpan">(parent, chartGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.dateFormat">
            function <span class="apidocSignatureSpan">dc.dc.</span>dateFormat
            <span class="apidocSignatureSpan">{{signature}}</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.deregisterAllCharts">
            function <span class="apidocSignatureSpan">dc.dc.</span>deregisterAllCharts
            <span class="apidocSignatureSpan">(group)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.deregisterChart">
            function <span class="apidocSignatureSpan">dc.dc.</span>deregisterChart
            <span class="apidocSignatureSpan">(chart, group)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.filterAll">
            function <span class="apidocSignatureSpan">dc.dc.</span>filterAll
            <span class="apidocSignatureSpan">(group)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.geoChoroplethChart">
            function <span class="apidocSignatureSpan">dc.dc.</span>geoChoroplethChart
            <span class="apidocSignatureSpan">(parent, chartGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.hasChart">
            function <span class="apidocSignatureSpan">dc.dc.</span>hasChart
            <span class="apidocSignatureSpan">(chart)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.heatMap">
            function <span class="apidocSignatureSpan">dc.dc.</span>heatMap
            <span class="apidocSignatureSpan">(parent, chartGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.instanceOfChart">
            function <span class="apidocSignatureSpan">dc.dc.</span>instanceOfChart
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.legend">
            function <span class="apidocSignatureSpan">dc.dc.</span>legend
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.lineChart">
            function <span class="apidocSignatureSpan">dc.dc.</span>lineChart
            <span class="apidocSignatureSpan">(parent, chartGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.marginMixin">
            function <span class="apidocSignatureSpan">dc.dc.</span>marginMixin
            <span class="apidocSignatureSpan">(_chart)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.marginable">
            function <span class="apidocSignatureSpan">dc.dc.</span>marginable
            <span class="apidocSignatureSpan">(_chart)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.numberDisplay">
            function <span class="apidocSignatureSpan">dc.dc.</span>numberDisplay
            <span class="apidocSignatureSpan">(parent, chartGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.optionalTransition">
            function <span class="apidocSignatureSpan">dc.dc.</span>optionalTransition
            <span class="apidocSignatureSpan">(enable, duration, delay, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.override">
            function <span class="apidocSignatureSpan">dc.dc.</span>override
            <span class="apidocSignatureSpan">(obj, functionName, newFunction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.pieChart">
            function <span class="apidocSignatureSpan">dc.dc.</span>pieChart
            <span class="apidocSignatureSpan">(parent, chartGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.pluck">
            function <span class="apidocSignatureSpan">dc.dc.</span>pluck
            <span class="apidocSignatureSpan">(n, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.redrawAll">
            function <span class="apidocSignatureSpan">dc.dc.</span>redrawAll
            <span class="apidocSignatureSpan">(group)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.refocusAll">
            function <span class="apidocSignatureSpan">dc.dc.</span>refocusAll
            <span class="apidocSignatureSpan">(group)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.registerChart">
            function <span class="apidocSignatureSpan">dc.dc.</span>registerChart
            <span class="apidocSignatureSpan">(chart, group)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.renderAll">
            function <span class="apidocSignatureSpan">dc.dc.</span>renderAll
            <span class="apidocSignatureSpan">(group)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.renderlet">
            function <span class="apidocSignatureSpan">dc.dc.</span>renderlet
            <span class="apidocSignatureSpan">(_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.rowChart">
            function <span class="apidocSignatureSpan">dc.dc.</span>rowChart
            <span class="apidocSignatureSpan">(parent, chartGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.scatterPlot">
            function <span class="apidocSignatureSpan">dc.dc.</span>scatterPlot
            <span class="apidocSignatureSpan">(parent, chartGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.seriesChart">
            function <span class="apidocSignatureSpan">dc.dc.</span>seriesChart
            <span class="apidocSignatureSpan">(parent, chartGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.stackMixin">
            function <span class="apidocSignatureSpan">dc.dc.</span>stackMixin
            <span class="apidocSignatureSpan">(_chart)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.stackableChart">
            function <span class="apidocSignatureSpan">dc.dc.</span>stackableChart
            <span class="apidocSignatureSpan">(_chart)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.dc.transition">
            function <span class="apidocSignatureSpan">dc.dc.</span>transition
            <span class="apidocSignatureSpan">(selection, duration, delay, name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.dc.</span>_renderlet</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.dc.</span>chartRegistry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.dc.</span>constants</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.dc.</span>d3</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.dc.</span>errors</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.dc.</span>events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.dc.</span>filters</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.dc.</span>logger</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.dc.</span>printers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.dc.</span>round</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.dc.</span>units</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.dc.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">dc.dc.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.dc.shCore">module dc.shCore</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dc.shCore.XRegExp">
            function <span class="apidocSignatureSpan">dc.shCore.</span>XRegExp
            <span class="apidocSignatureSpan">(f, e)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dc.shCore.</span>SyntaxHighlighter</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.dc" id="apidoc.module.dc">module dc</a></h1>









</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.dc.crossfilter" id="apidoc.module.dc.crossfilter">module dc.crossfilter</a></h1>


    <h2>
        <a href="#apidoc.element.dc.crossfilter.crossfilter" id="apidoc.element.dc.crossfilter.crossfilter">
        function <span class="apidocSignatureSpan">dc.</span>crossfilter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function crossfilter() {
  var crossfilter = {
    add: add,
    remove: removeData,
    dimension: dimension,
    groupAll: groupAll,
    size: size
  };

  var data = [], // the records
      n = 0, // the number of records; data.length
      m = 0, // a bit mask representing which dimensions are in use
      M = 8, // number of dimensions that can fit in `filters`
      filters = crossfilter_array8(0), // M bits per record; 1 is filtered out
      filterListeners = [], // when the filters change
      dataListeners = [], // when data is added
      removeDataListeners = []; // when data is removed

  // Adds the specified new records to this crossfilter.
  function add(newData) {
    var n0 = n,
        n1 = newData.length;

    // If there&#x27;s actually new data to add…
    // Merge the new data into the existing data.
    // Lengthen the filter bitset to handle the new records.
    // Notify listeners (dimensions and groups) that new data is available.
    if (n1) {
      data = data.concat(newData);
      filters = crossfilter_arrayLengthen(filters, n += n1);
      dataListeners.forEach(function(l) { l(newData, n0, n1); });
    }

    return crossfilter;
  }

  // Removes all records that match the current filters.
  function removeData() {
    var newIndex = crossfilter_index(n, n),
        removed = [];
    for (var i = 0, j = 0; i &#x3c; n; ++i) {
      if (filters[i]) newIndex[i] = j++;
      else removed.push(i);
    }

    // Remove all matching records from groups.
    filterListeners.forEach(function(l) { l(0, [], removed); });

    // Update indexes.
    removeDataListeners.forEach(function(l) { l(newIndex); });

    // Remove old filters and data by overwriting.
    for (var i = 0, j = 0, k; i &#x3c; n; ++i) {
      if (k = filters[i]) {
        if (i !== j) filters[j] = k, data[j] = data[i];
        ++j;
      }
    }
    data.length = j;
    while (n &#x3e; j) filters[--n] = 0;
  }

  // Adds a new dimension with the specified value accessor function.
  function dimension(value) {
    var dimension = {
      filter: filter,
      filterExact: filterExact,
      filterRange: filterRange,
      filterFunction: filterFunction,
      filterAll: filterAll,
      top: top,
      bottom: bottom,
      group: group,
      groupAll: groupAll,
      dispose: dispose,
      remove: dispose // for backwards-compatibility
    };

    var one = ~m &#x26; -~m, // lowest unset bit as mask, e.g., 00001000
        zero = ~one, // inverted one, e.g., 11110111
        values, // sorted, cached array
        index, // value rank ↦ object id
        newValues, // temporary array storing newly-added values
        newIndex, // temporary array storing newly-added index
        sort = quicksort_by(function(i) { return newValues[i]; }),
        refilter = crossfilter_filterAll, // for recomputing filter
        refilterFunction, // the custom filter function in use
        indexListeners = [], // when data is added
        dimensionGroups = [],
        lo0 = 0,
        hi0 = 0;

    // Updating a dimension is a two-stage process. First, we must update the
    // associated filters for the newly-added records. Once all dimensions have
    // updated their filters, the groups are notified to update.
    dataListeners.unshift(preAdd);
    dataListeners.push(postAdd);

    removeDataListeners.push(removeData);

    // Incorporate any existing data into this dimension, and make sure that the
    // filter bitset is wide enough to handle the new dimension.
    m |= one;
    if (M &#x3e;= 32 ? !one : m &#x26; -(1 &#x3c;&#x3c; M)) {
      filters = crossfilter_arrayWiden(filters, M &#x3c;&#x3c;= 1);
    }
    preAdd(data, 0, n);
    postAdd(data, 0, n);

    // Incorporates the specified new records into this dimension.
    // This function is responsible for updating filters, values, and index.
    function preAdd(newData, n0, n1) {

      // Permute new values into natural order using a sorted index.
      newValues = newData.map(value);
      newIndex = sort(crossfilter_range(n1), 0, n1);
      newValues = permute(newValues, newIndex);

      // Bisect newValues to determine which new ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.dc.d3" id="apidoc.module.dc.d3">module dc.d3</a></h1>


    <h2>
        <a href="#apidoc.element.dc.d3.ascending" id="apidoc.element.dc.d3.ascending">
        function <span class="apidocSignatureSpan">dc.d3.</span>ascending
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function d3_ascending(a, b) {
  return a &#x3c; b ? -1 : a &#x3e; b ? 1 : a &#x3e;= b ? 0 : NaN;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Interaction with a chart will only trigger events and redraws within the chart&#x27;s group.
 * @returns {dc.seriesChart}
 */
dc.seriesChart = function (parent, chartGroup) {
var _chart = dc.compositeChart(parent, chartGroup);

function keySort (a, b) {
    return d3.<span class="apidocCodeKeywordSpan">ascending</span>(_chart.keyAccessor()(a), _chart.keyAccessor()(b));
}

var _charts = {};
var _chartFunction = dc.lineChart;
var _seriesAccessor;
var _seriesSort = d3.ascending;
var _valueSort = keySort;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.bisect" id="apidoc.element.dc.d3.bisect">
        function <span class="apidocSignatureSpan">dc.d3.</span>bisect
        <span class="apidocSignatureSpan">(a, x, lo, hi)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bisect = function (a, x, lo, hi) {
  if (arguments.length &#x3c; 3) lo = 0;
  if (arguments.length &#x3c; 4) hi = a.length;
  while (lo &#x3c; hi) {
    var mid = lo + hi &#x3e;&#x3e;&#x3e; 1;
    if (compare(a[mid], x) &#x3e; 0) hi = mid; else lo = mid + 1;
  }
  return lo;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    bin.y = 0;
  }
  if (m &#x3e; 0) {
    i = -1;
    while (++i &#x3c; n) {
      x = values[i];
      if (x &#x3e;= range[0] &#x26;&#x26; x &#x3c;= range[1]) {
        bin = bins[d3.<span class="apidocCodeKeywordSpan">bisect</span>(thresholds, x, 1, m) - 1];
        bin.y += k;
        bin.push(data[i]);
      }
    }
  }
  return bins;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.bisectLeft" id="apidoc.element.dc.d3.bisectLeft">
        function <span class="apidocSignatureSpan">dc.d3.</span>bisectLeft
        <span class="apidocSignatureSpan">(a, x, lo, hi)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bisectLeft = function (a, x, lo, hi) {
  if (arguments.length &#x3c; 3) lo = 0;
  if (arguments.length &#x3c; 4) hi = a.length;
  while (lo &#x3c; hi) {
    var mid = lo + hi &#x3e;&#x3e;&#x3e; 1;
    if (compare(a[mid], x) &#x3c; 0) lo = mid + 1; else hi = mid;
  }
  return lo;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.bisectRight" id="apidoc.element.dc.d3.bisectRight">
        function <span class="apidocSignatureSpan">dc.d3.</span>bisectRight
        <span class="apidocSignatureSpan">(a, x, lo, hi)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bisectRight = function (a, x, lo, hi) {
  if (arguments.length &#x3c; 3) lo = 0;
  if (arguments.length &#x3c; 4) hi = a.length;
  while (lo &#x3c; hi) {
    var mid = lo + hi &#x3e;&#x3e;&#x3e; 1;
    if (compare(a[mid], x) &#x3e; 0) hi = mid; else lo = mid + 1;
  }
  return lo;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.bisector" id="apidoc.element.dc.d3.bisector">
        function <span class="apidocSignatureSpan">dc.d3.</span>bisector
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bisector = function (f) {
  return d3_bisector(f.length === 1 ? function(d, x) {
    return d3_ascending(f(d), x);
  } : f);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.color" id="apidoc.element.dc.d3.color">
        function <span class="apidocSignatureSpan">dc.d3.</span>color
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function d3_color() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.csv" id="apidoc.element.dc.d3.csv">
        function <span class="apidocSignatureSpan">dc.d3.</span>csv
        <span class="apidocSignatureSpan">(url, row, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dsv(url, row, callback) {
  if (arguments.length &#x3c; 3) callback = row, row = null;
  var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
  xhr.row = function(_) {
    return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
  };
  return xhr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.descending" id="apidoc.element.dc.d3.descending">
        function <span class="apidocSignatureSpan">dc.d3.</span>descending
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">descending = function (a, b) {
  return b &#x3c; a ? -1 : b &#x3e; a ? 1 : b &#x3e;= a ? 0 : NaN;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

_chart.r().range([_chart.MIN_RADIUS, _chart.xAxisLength() * _chart.maxBubbleRelativeSize()]);

var data = _chart.data();
if (_sortBubbleSize) {
    // sort descending so smaller bubbles are on top
    var radiusAccessor = _chart.radiusValueAccessor();
    data.sort(function (a, b) { return d3.<span class="apidocCodeKeywordSpan">descending</span>(radiusAccessor(a), radiusAccessor
(b)); });
}
var bubbleG = _chart.chartBodyG().selectAll(&#x27;g.&#x27; + _chart.BUBBLE_NODE_CLASS)
        .data(data, function (d) { return d.key; });
if (_sortBubbleSize) {
    // Call order here to update dom order based on sort
    bubbleG.order();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.deviation" id="apidoc.element.dc.d3.deviation">
        function <span class="apidocSignatureSpan">dc.d3.</span>deviation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deviation = function () {
  var v = d3.variance.apply(this, arguments);
  return v ? Math.sqrt(v) : v;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.dispatch" id="apidoc.element.dc.d3.dispatch">
        function <span class="apidocSignatureSpan">dc.d3.</span>dispatch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispatch = function () {
  var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
  while (++i &#x3c; n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
  return dispatch;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var _filterPrinter = dc.printers.filters;

var _mandatoryAttributes = [&#x27;dimension&#x27;, &#x27;group&#x27;];

var _chartGroup = dc.constants.DEFAULT_CHART_GROUP;

var _listeners = d3.<span class="apidocCodeKeywordSpan">dispatch</span>(
    &#x27;preRender&#x27;,
    &#x27;postRender&#x27;,
    &#x27;preRedraw&#x27;,
    &#x27;postRedraw&#x27;,
    &#x27;filtered&#x27;,
    &#x27;zoomed&#x27;,
    &#x27;renderlet&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.dsv" id="apidoc.element.dc.d3.dsv">
        function <span class="apidocSignatureSpan">dc.d3.</span>dsv
        <span class="apidocSignatureSpan">(delimiter, mimeType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dsv = function (delimiter, mimeType) {
  var reFormat = new RegExp(&#x27;[&#x22;&#x27; + delimiter + &#x22;\n]&#x22;), delimiterCode = delimiter.charCodeAt(0);
  function dsv(url, row, callback) {
    if (arguments.length &#x3c; 3) callback = row, row = null;
    var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
    xhr.row = function(_) {
      return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
    };
    return xhr;
  }
  function response(request) {
    return dsv.parse(request.responseText);
  }
  function typedResponse(f) {
    return function(request) {
      return dsv.parse(request.responseText, f);
    };
  }
  dsv.parse = function(text, f) {
    var o;
    return dsv.parseRows(text, function(row, i) {
      if (o) return o(row, i - 1);
      var a = new Function(&#x22;d&#x22;, &#x22;return {&#x22; + row.map(function(name, i) {
        return JSON.stringify(name) + &#x22;: d[&#x22; + i + &#x22;]&#x22;;
      }).join(&#x22;,&#x22;) + &#x22;}&#x22;);
      o = f ? function(row, i) {
        return f(a(row), i);
      } : a;
    });
  };
  dsv.parseRows = function(text, f) {
    var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
    function token() {
      if (I &#x3e;= N) return EOF;
      if (eol) return eol = false, EOL;
      var j = I;
      if (text.charCodeAt(j) === 34) {
        var i = j;
        while (i++ &#x3c; N) {
          if (text.charCodeAt(i) === 34) {
            if (text.charCodeAt(i + 1) !== 34) break;
            ++i;
          }
        }
        I = i + 2;
        var c = text.charCodeAt(i + 1);
        if (c === 13) {
          eol = true;
          if (text.charCodeAt(i + 2) === 10) ++I;
        } else if (c === 10) {
          eol = true;
        }
        return text.slice(j + 1, i).replace(/&#x22;&#x22;/g, &#x27;&#x22;&#x27;);
      }
      while (I &#x3c; N) {
        var c = text.charCodeAt(I++), k = 1;
        if (c === 10) eol = true; else if (c === 13) {
          eol = true;
          if (text.charCodeAt(I) === 10) ++I, ++k;
        } else if (c !== delimiterCode) continue;
        return text.slice(j, I - k);
      }
      return text.slice(j);
    }
    while ((t = token()) !== EOF) {
      var a = [];
      while (t !== EOL &#x26;&#x26; t !== EOF) {
        a.push(t);
        t = token();
      }
      if (f &#x26;&#x26; (a = f(a, n++)) == null) continue;
      rows.push(a);
    }
    return rows;
  };
  dsv.format = function(rows) {
    if (Array.isArray(rows[0])) return dsv.formatRows(rows);
    var fieldSet = new d3_Set(), fields = [];
    rows.forEach(function(row) {
      for (var field in row) {
        if (!fieldSet.has(field)) {
          fields.push(fieldSet.add(field));
        }
      }
    });
    return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
      return fields.map(function(field) {
        return formatValue(row[field]);
      }).join(delimiter);
    })).join(&#x22;\n&#x22;);
  };
  dsv.formatRows = function(rows) {
    return rows.map(formatRow).join(&#x22;\n&#x22;);
  };
  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }
  function formatValue(text) {
    return reFormat.test(text) ? &#x27;&#x22;&#x27; + text.replace(/\&#x22;/g, &#x27;&#x22;&#x22;&#x27;) + &#x27;&#x22;&#x27; : text;
  }
  return dsv;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return row.map(formatValue).join(delimiter);
  }
  function formatValue(text) {
    return reFormat.test(text) ? &#x27;&#x22;&#x27; + text.replace(/\&#x22;/g, &#x27;&#x22;&#x22;&#x27;) + &#x27;&#x22;&#x27; :
text;
  }
  return dsv;
};
d3.csv = d3.<span class="apidocCodeKeywordSpan">dsv</span>(&#x22;,&#x22;, &#x22;text/csv&#x22;);
d3.tsv = d3.dsv(&#x22;	&#x22;, &#x22;text/tab-separated-values&#x22;);
var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, &#x22
;requestAnimationFrame&#x22;)] || function(callback) {
  setTimeout(callback, 17);
};
d3.timer = function() {
  d3_timer.apply(this, arguments);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.ease" id="apidoc.element.dc.d3.ease">
        function <span class="apidocSignatureSpan">dc.d3.</span>ease
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ease = function (name) {
  var i = name.indexOf(&#x22;-&#x22;), t = i &#x3e;= 0 ? name.slice(0, i) : name, m = i &#x3e;= 0 ? name.slice(i + 1) : &#x22;in&#x22;;
  t = d3_ease.get(t) || d3_ease_default;
  m = d3_ease_mode.get(m) || d3_identity;
  return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        .attr(&#x27;class&#x27;, &#x27;line&#x27;)
        .attr(&#x27;stroke&#x27;, colors);
    if (_dashStyle) {
        path.attr(&#x27;stroke-dasharray&#x27;, _dashStyle);
    }

    dc.transition(layers.select(&#x27;path.line&#x27;), _chart.transitionDuration(), _chart.transitionDelay())
        //.<span class="apidocCodeKeywordSpan">ease</span>(&#x27;linear&#x27;)
        .attr(&#x27;stroke&#x27;, colors)
        .attr(&#x27;d&#x27;, function (d) {
            return safeD(line(d.values));
        });
}

function drawArea (layersEnter, layers) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.entries" id="apidoc.element.dc.d3.entries">
        function <span class="apidocSignatureSpan">dc.d3.</span>entries
        <span class="apidocSignatureSpan">(map)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">entries = function (map) {
  var entries = [];
  for (var key in map) entries.push({
    key: key,
    value: map[key]
  });
  return entries;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
        entries = _chart.dimension().top(_size);
    }

    return d3.nest()
        .key(_chart.group())
        .sortKeys(_order)
        .<span class="apidocCodeKeywordSpan">entries</span>(entries.sort(function (a, b) {
            return _order(_sortBy(a), _sortBy(b));
        }).slice(_beginSlice, _endSlice));
}

function renderRows (groups) {
    var rows = groups.order()
        .selectAll(&#x27;tr.&#x27; + ROW_CSS_CLASS)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.extent" id="apidoc.element.dc.d3.extent">
        function <span class="apidocSignatureSpan">dc.d3.</span>extent
        <span class="apidocSignatureSpan">(array, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extent = function (array, f) {
  var i = -1, n = array.length, a, b, c;
  if (arguments.length === 1) {
    while (++i &#x3c; n) if ((b = array[i]) != null &#x26;&#x26; b &#x3e;= b) {
      a = c = b;
      break;
    }
    while (++i &#x3c; n) if ((b = array[i]) != null) {
      if (a &#x3e; b) a = b;
      if (c &#x3c; b) c = b;
    }
  } else {
    while (++i &#x3c; n) if ((b = f.call(array, array[i], i)) != null &#x26;&#x26; b &#x3e;= b) {
      a = c = b;
      break;
    }
    while (++i &#x3c; n) if ((b = f.call(array, array[i], i)) != null) {
      if (a &#x3e; b) a = b;
      if (c &#x3c; b) c = b;
    }
  }
  return [ a, c ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!arguments.length) {
        return _chart._filter();
    }

    _chart._filter(_);

    if (_) {
        _chart.brush().<span class="apidocCodeKeywordSpan">extent</span>(_);
    } else {
        _chart.brush().clear();
    }

    return _chart;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.format" id="apidoc.element.dc.d3.format">
        function <span class="apidocSignatureSpan">dc.d3.</span>format
        <span class="apidocSignatureSpan">(specifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format = function (specifier) {
  var match = d3_format_re.exec(specifier), fill = match[1] || &#x22; &#x22;, align = match[2] || &#x22;&#x3e;&#x22;, sign = match[3] || &#x22;-&#x22;, symbol = match
[4] || &#x22;&#x22;, zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = &#x22;&#x22;,
suffix = &#x22;&#x22;, integer = false, exponent = true;
  if (precision) precision = +precision.substring(1);
  if (zfill || fill === &#x22;0&#x22; &#x26;&#x26; align === &#x22;=&#x22;) {
    zfill = fill = &#x22;0&#x22;;
    align = &#x22;=&#x22;;
  }
  switch (type) {
   case &#x22;n&#x22;:
    comma = true;
    type = &#x22;g&#x22;;
    break;

   case &#x22;%&#x22;:
    scale = 100;
    suffix = &#x22;%&#x22;;
    type = &#x22;f&#x22;;
    break;

   case &#x22;p&#x22;:
    scale = 100;
    suffix = &#x22;%&#x22;;
    type = &#x22;r&#x22;;
    break;

   case &#x22;b&#x22;:
   case &#x22;o&#x22;:
   case &#x22;x&#x22;:
   case &#x22;X&#x22;:
    if (symbol === &#x22;#&#x22;) prefix = &#x22;0&#x22; + type.toLowerCase();

   case &#x22;c&#x22;:
    exponent = false;

   case &#x22;d&#x22;:
    integer = true;
    precision = 0;
    break;

   case &#x22;s&#x22;:
    scale = -1;
    type = &#x22;r&#x22;;
    break;
  }
  if (symbol === &#x22;$&#x22;) prefix = locale_currency[0], suffix = locale_currency[1];
  if (type == &#x22;r&#x22; &#x26;&#x26; !precision) type = &#x22;g&#x22;;
  if (precision != null) {
    if (type == &#x22;g&#x22;) precision = Math.max(1, Math.min(21, precision)); else if (type == &#x22;e&#x22; || type == &#x22;f&#x22;) precision = Math.max
(0, Math.min(20, precision));
  }
  type = d3_format_types.get(type) || d3_format_typeDefault;
  var zcomma = zfill &#x26;&#x26; comma;
  return function(value) {
    var fullSuffix = suffix;
    if (integer &#x26;&#x26; value % 1) return &#x22;&#x22;;
    var negative = value &#x3c; 0 || value === 0 &#x26;&#x26; 1 / value &#x3c; 0 ? (value = -value, &#x22;-&#x22;) : sign === &#x22;-&#x22; ? &#x22;&#x22; : sign;
    if (scale &#x3c; 0) {
      var unit = d3.formatPrefix(value, precision);
      value = unit.scale(value);
      fullSuffix = unit.symbol + suffix;
    } else {
      value *= scale;
    }
    value = type(value, precision);
    var i = value.lastIndexOf(&#x22;.&#x22;), before, after;
    if (i &#x3c; 0) {
      var j = exponent ? value.lastIndexOf(&#x22;e&#x22;) : -1;
      if (j &#x3c; 0) before = value, after = &#x22;&#x22;; else before = value.substring(0, j), after = value.substring(j);
    } else {
      before = value.substring(0, i);
      after = locale_decimal + value.substring(i + 1);
    }
    if (!zfill &#x26;&#x26; comma) before = formatGroup(before, Infinity);
    var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length &#x3c; width ? new Array
(length = width - length + 1).join(fill) : &#x22;&#x22;;
    if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
    negative += prefix;
    value = before + after;
    return (align === &#x22;&#x3c;&#x22; ? negative + value + padding : align === &#x22;&#x3e;&#x22; ? padding + negative + value : align === &#x22;^&#x22; ? padding.substring
(0, length &#x3e;&#x3e;= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
dc.errors.BadArgumentException.prototype.constructor = dc.errors.BadArgumentException;

/**
* The default date format for dc.js
* @name dateFormat
* @memberof dc
* @type {Function}
* @default d3.time.<span class="apidocCodeKeywordSpan">format</span>(&#x27;%m/%d/%Y&#x27;)
*/
dc.dateFormat = d3.time.format(&#x27;%m/%d/%Y&#x27;);

/**
* @namespace printers
* @memberof dc
* @type {{}}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.formatPrefix" id="apidoc.element.dc.d3.formatPrefix">
        function <span class="apidocSignatureSpan">dc.d3.</span>formatPrefix
        <span class="apidocSignatureSpan">(value, precision)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatPrefix = function (value, precision) {
  var i = 0;
  if (value = +value) {
    if (value &#x3c; 0) value *= -1;
    if (precision) value = d3.round(value, d3_format_precision(value, precision));
    i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
    i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
  }
  return d3_formatPrefixes[8 + i / 3];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
type = d3_format_types.get(type) || d3_format_typeDefault;
var zcomma = zfill &#x26;&#x26; comma;
return function(value) {
  var fullSuffix = suffix;
  if (integer &#x26;&#x26; value % 1) return &#x22;&#x22;;
  var negative = value &#x3c; 0 || value === 0 &#x26;&#x26; 1 / value &#x3c; 0 ? (value = -value, &#x22;-&#x22;) : sign === &#x22
;-&#x22; ? &#x22;&#x22; : sign;
  if (scale &#x3c; 0) {
    var unit = d3.<span class="apidocCodeKeywordSpan">formatPrefix</span>(value, precision);
    value = unit.scale(value);
    fullSuffix = unit.symbol + suffix;
  } else {
    value *= scale;
  }
  value = type(value, precision);
  var i = value.lastIndexOf(&#x22;.&#x22;), before, after;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.functor" id="apidoc.element.dc.d3.functor">
        function <span class="apidocSignatureSpan">dc.d3.</span>functor
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function d3_functor(v) {
  return typeof v === &#x22;function&#x22; ? v : function() {
    return v;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!arguments.length) {
        if (!dc.utils.isNumber(_height)) {
            // only calculate once
            _height = _heightCalc(_root.node());
        }
        return _height;
    }
    _heightCalc = d3.<span class="apidocCodeKeywordSpan">functor</span>(height || _defaultHeightCalc);
    _height = undefined;
    return _chart;
};

/**
 * Set or get the width attribute of a chart.
 * @method width
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.hcl" id="apidoc.element.dc.d3.hcl">
        function <span class="apidocSignatureSpan">dc.d3.</span>hcl
        <span class="apidocSignatureSpan">(h, c, l)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function d3_hcl(h, c, l) {
  return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length &#x3c; 2 ? h instanceof d3_hcl ? new
 d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.
b)).l, h.a, h.b) : new d3_hcl(h, c, l);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };
}
function d3_ease_bounce(t) {
  return t &#x3c; 1 / 2.75 ? 7.5625 * t * t : t &#x3c; 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t &#x3c; 2.5 / 2.75 ? 7
.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
}
d3.interpolateHcl = d3_interpolateHcl;
function d3_interpolateHcl(a, b) {
  a = d3.<span class="apidocCodeKeywordSpan">hcl</span>(a);
  b = d3.hcl(b);
  var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
  if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
  if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh &#x3e; 180) bh -= 360; else if (bh &#x3c; -180) bh += 360;
  return function(t) {
    return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + &#x22;&#x22;;
  };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.hsl" id="apidoc.element.dc.d3.hsl">
        function <span class="apidocSignatureSpan">dc.d3.</span>hsl
        <span class="apidocSignatureSpan">(h, s, l)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function d3_hsl(h, s, l) {
  return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length &#x3c; 2 ? h instanceof d3_hsl ? new
 d3_hsl(h.h, h.s, h.l) : d3_rgb_parse(&#x22;&#x22; + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh &#x3e; 180) bh -= 360; else if (bh &#x3c; -180) bh += 360;
  return function(t) {
    return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + &#x22;&#x22;;
  };
}
d3.interpolateHsl = d3_interpolateHsl;
function d3_interpolateHsl(a, b) {
  a = d3.<span class="apidocCodeKeywordSpan">hsl</span>(a);
  b = d3.hsl(b);
  var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
  if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
  if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh &#x3e; 180) bh -= 360; else if (bh &#x3c; -180) bh += 360;
  return function(t) {
    return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + &#x22;&#x22;;
  };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.html" id="apidoc.element.dc.d3.html">
        function <span class="apidocSignatureSpan">dc.d3.</span>html
        <span class="apidocSignatureSpan">(url, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">html = function (url, callback) {
  return d3_xhr(url, &#x22;text/html&#x22;, d3_html, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * `%filter-count` will be replaced with the number of selected records.
 * - all: HTML template to use if all items are selected
 * - some: HTML template to use if not all items are selected
 * @method html
 * @memberof dc.dataCount
 * @instance
 * @example
 * counter.<span class="apidocCodeKeywordSpan">html</span>({
 *      some: &#x27;%filter-count out of %total-count records selected&#x27;,
 *      all: &#x27;All records selected. Click on charts to apply filters&#x27;
 * })
 * @param {{some:String, all: String}} [options]
 * @returns {{some:String, all: String}|dc.dataCount}
 */
_chart.html = function (options) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.interpolate" id="apidoc.element.dc.d3.interpolate">
        function <span class="apidocSignatureSpan">dc.d3.</span>interpolate
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function d3_interpolate(a, b) {
  var i = d3.interpolators.length, f;
  while (--i &#x3e;= 0 &#x26;&#x26; !(f = d3.interpolators[i](a, b))) ;
  return f;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @instance
 * @param {Array&#x3c;Number&#x3e;} r
 * @returns {dc.colorMixin}
 */
_chart.linearColors = function (r) {
    return _chart.colors(d3.scale.linear()
                         .range(r)
                         .<span class="apidocCodeKeywordSpan">interpolate</span>(d3.interpolateHcl));
};

/**
 * Set or the get color accessor function. This function will be used to map a data point in a
 * crossfilter group to a color value on the color scale. The default function uses the key
 * accessor.
 * @method colorAccessor
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.interpolateArray" id="apidoc.element.dc.d3.interpolateArray">
        function <span class="apidocSignatureSpan">dc.d3.</span>interpolateArray
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function d3_interpolateArray(a, b) {
  var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
  for (i = 0; i &#x3c; n0; ++i) x.push(d3_interpolate(a[i], b[i]));
  for (;i &#x3c; na; ++i) c[i] = a[i];
  for (;i &#x3c; nb; ++i) c[i] = b[i];
  return function(t) {
    for (i = 0; i &#x3c; n0; ++i) c[i] = x[i](t);
    return c;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.interpolateHcl" id="apidoc.element.dc.d3.interpolateHcl">
        function <span class="apidocSignatureSpan">dc.d3.</span>interpolateHcl
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function d3_interpolateHcl(a, b) {
  a = d3.hcl(a);
  b = d3.hcl(b);
  var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
  if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
  if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh &#x3e; 180) bh -= 360; else if (bh &#x3c; -180) bh += 360;
  return function(t) {
    return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + &#x22;&#x22;;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.interpolateHsl" id="apidoc.element.dc.d3.interpolateHsl">
        function <span class="apidocSignatureSpan">dc.d3.</span>interpolateHsl
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function d3_interpolateHsl(a, b) {
  a = d3.hsl(a);
  b = d3.hsl(b);
  var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
  if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
  if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh &#x3e; 180) bh -= 360; else if (bh &#x3c; -180) bh += 360;
  return function(t) {
    return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + &#x22;&#x22;;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.interpolateLab" id="apidoc.element.dc.d3.interpolateLab">
        function <span class="apidocSignatureSpan">dc.d3.</span>interpolateLab
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function d3_interpolateLab(a, b) {
  a = d3.lab(a);
  b = d3.lab(b);
  var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
  return function(t) {
    return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + &#x22;&#x22;;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.interpolateNumber" id="apidoc.element.dc.d3.interpolateNumber">
        function <span class="apidocSignatureSpan">dc.d3.</span>interpolateNumber
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function d3_interpolateNumber(a, b) {
  a = +a, b = +b;
  return function(t) {
    return a * (1 - t) + b * t;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        span.transition()
.duration(_chart.transitionDuration())
.delay(_chart.transitionDelay())
.ease(&#x27;quad-out-in&#x27;)
.tween(&#x27;text&#x27;, function () {
    // [XA] don&#x27;t try and interpolate from Infinity, else this breaks.
    var interpStart = isFinite(_lastValue) ? _lastValue : 0;
    var interp = d3.<span class="apidocCodeKeywordSpan">interpolateNumber</span>(interpStart || 0, newValue);
    _lastValue = newValue;
    return function (t) {
        var html = null, num = _chart.formatNumber()(interp(t));
        if (newValue === 0 &#x26;&#x26; (_html.none !== &#x27;&#x27;)) {
            html = _html.none;
        } else if (newValue === 1 &#x26;&#x26; (_html.one !== &#x27;&#x27;)) {
            html = _html.one;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.interpolateObject" id="apidoc.element.dc.d3.interpolateObject">
        function <span class="apidocSignatureSpan">dc.d3.</span>interpolateObject
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function d3_interpolateObject(a, b) {
  var i = {}, c = {}, k;
  for (k in a) {
    if (k in b) {
      i[k] = d3_interpolate(a[k], b[k]);
    } else {
      c[k] = a[k];
    }
  }
  for (k in b) {
    if (!(k in a)) {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.interpolateRgb" id="apidoc.element.dc.d3.interpolateRgb">
        function <span class="apidocSignatureSpan">dc.d3.</span>interpolateRgb
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function d3_interpolateRgb(a, b) {
  a = d3.rgb(a);
  b = d3.rgb(b);
  var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
  return function(t) {
    return &#x22;#&#x22; + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.interpolateRound" id="apidoc.element.dc.d3.interpolateRound">
        function <span class="apidocSignatureSpan">dc.d3.</span>interpolateRound
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function d3_interpolateRound(a, b) {
  b -= a;
  return function(t) {
    return Math.round(a + b * t);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.interpolateString" id="apidoc.element.dc.d3.interpolateString">
        function <span class="apidocSignatureSpan">dc.d3.</span>interpolateString
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function d3_interpolateString(a, b) {
  var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + &#x22;&#x22;, b = b + &#x22;&#x22;;
  while ((am = d3_interpolate_numberA.exec(a)) &#x26;&#x26; (bm = d3_interpolate_numberB.exec(b))) {
    if ((bs = bm.index) &#x3e; bi) {
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i]) s[i] += bm; else s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({
        i: i,
        x: d3_interpolateNumber(am, bm)
      });
    }
    bi = d3_interpolate_numberB.lastIndex;
  }
  if (bi &#x3c; b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; else s[++i] = bs;
  }
  return s.length &#x3c; 2 ? q[0] ? (b = q[0].x, function(t) {
    return b(t) + &#x22;&#x22;;
  }) : function() {
    return b;
  } : (b = q.length, function(t) {
    for (var i = 0, o; i &#x3c; b; ++i) s[(o = q[i]).i] = o.x(t);
    return s.join(&#x22;&#x22;);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.interpolateTransform" id="apidoc.element.dc.d3.interpolateTransform">
        function <span class="apidocSignatureSpan">dc.d3.</span>interpolateTransform
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function d3_interpolateTransform(a, b) {
  var s = [], q = [];
  a = d3.transform(a), b = d3.transform(b);
  d3_interpolateTranslate(a.translate, b.translate, s, q);
  d3_interpolateRotate(a.rotate, b.rotate, s, q);
  d3_interpolateSkew(a.skew, b.skew, s, q);
  d3_interpolateScale(a.scale, b.scale, s, q);
  a = b = null;
  return function(t) {
    var i = -1, n = q.length, o;
    while (++i &#x3c; n) s[(o = q[i]).i] = o.x(t);
    return s.join(&#x22;&#x22;);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.interpolateZoom" id="apidoc.element.dc.d3.interpolateZoom">
        function <span class="apidocSignatureSpan">dc.d3.</span>interpolateZoom
        <span class="apidocSignatureSpan">(p0, p1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interpolateZoom = function (p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx +
dy * dy, i, S;
  if (d2 &#x3c; ε2) {
    S = Math.log(w1 / w0) / ρ;
    i = function(t) {
      return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S) ];
    };
  } else {
    var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1
 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / ρ;
    i = function(t) {
      var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
      return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
    };
  }
  i.duration = S * 1e3;
  return i;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  view = this.__chart__ || {
    x: 0,
    y: 0,
    k: 1
  };
  zoomstarted(dispatch);
}).tween(&#x22;zoom:zoom&#x22;, function() {
  var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.<span class="apidocCodeKeywordSpan
">interpolateZoom</span>([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1
.y) / view1.k, dx / view1.k ]);
  return function(t) {
    var l = i(t), k = dx / l[2];
    this.__chart__ = view = {
      x: cx - l[0] * k,
      y: cy - l[1] * k,
      k: k
    };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.json" id="apidoc.element.dc.d3.json">
        function <span class="apidocSignatureSpan">dc.d3.</span>json
        <span class="apidocSignatureSpan">(url, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">json = function (url, callback) {
  return d3_xhr(url, &#x22;application/json&#x22;, d3_json, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function ordinal_filter(bins) {
    return function(d) {
return bins.indexOf(d) &#x3e;=0;
    };
}

function startOrdinal(initChart) {
    d3.<span class="apidocCodeKeywordSpan">json</span>(&#x27;../examples/fruits.json&#x27;, function(error, counts) {
if(error)
    throw new Error(error);

var ndx            = crossfilter(counts),
    fruitDimension = ndx.dimension(function(d) {return d.name;}),
    sumGroup       = fruitDimension.group().reduceSum(function(d) {return d.cnt;}),
    sumGroupFiltered = remove_empty_bins(sumGroup),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.keys" id="apidoc.element.dc.d3.keys">
        function <span class="apidocSignatureSpan">dc.d3.</span>keys
        <span class="apidocSignatureSpan">(map)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keys = function (map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            .group({all: d3.functor(sub.values)}, sub.key)
            .keyAccessor(_chart.keyAccessor())
            .valueAccessor(_chart.valueAccessor())
            .brushOn(_chart.brushOn());
    });
// this works around the fact compositeChart doesn&#x27;t really
// have a removal interface
Object.<span class="apidocCodeKeywordSpan">keys</span>(_charts)
    .filter(function (c) {return keep.indexOf(c) === -1;})
    .forEach(function (c) {
        clearChart(c);
        childrenChanged = true;
    });
_chart._compose(children);
if (childrenChanged &#x26;&#x26; _chart.legend()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.lab" id="apidoc.element.dc.d3.lab">
        function <span class="apidocSignatureSpan">dc.d3.</span>lab
        <span class="apidocSignatureSpan">(l, a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function d3_lab(l, a, b) {
  return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length &#x3c; 2 ? l instanceof d3_lab ? new
 d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(
l, a, b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh &#x3e; 180) bh -= 360; else if (bh &#x3c; -180) bh += 360;
  return function(t) {
    return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + &#x22;&#x22;;
  };
}
d3.interpolateLab = d3_interpolateLab;
function d3_interpolateLab(a, b) {
  a = d3.<span class="apidocCodeKeywordSpan">lab</span>(a);
  b = d3.lab(b);
  var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
  return function(t) {
    return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + &#x22;&#x22;;
  };
}
d3.interpolateRound = d3_interpolateRound;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.locale" id="apidoc.element.dc.d3.locale">
        function <span class="apidocSignatureSpan">dc.d3.</span>locale
        <span class="apidocSignatureSpan">(locale)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">locale = function (locale) {
  return {
    numberFormat: d3_locale_numberFormat(locale),
    timeFormat: d3_locale_timeFormat(locale)
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
d3.locale = function(locale) {
  return {
    numberFormat: d3_locale_numberFormat(locale),
    timeFormat: d3_locale_timeFormat(locale)
  };
};
var d3_locale_enUS = d3.<span class="apidocCodeKeywordSpan">locale</span>({
  decimal: &#x22;.&#x22;,
  thousands: &#x22;,&#x22;,
  grouping: [ 3 ],
  currency: [ &#x22;$&#x22;, &#x22;&#x22; ],
  dateTime: &#x22;%a %b %e %X %Y&#x22;,
  date: &#x22;%m/%d/%Y&#x22;,
  time: &#x22;%H:%M:%S&#x22;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.map" id="apidoc.element.dc.d3.map">
        function <span class="apidocSignatureSpan">dc.d3.</span>map
        <span class="apidocSignatureSpan">(object, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (object, f) {
  var map = new d3_Map();
  if (object instanceof d3_Map) {
    object.forEach(function(key, value) {
      map.set(key, value);
    });
  } else if (Array.isArray(object)) {
    var i = -1, n = object.length, o;
    if (arguments.length === 1) while (++i &#x3c; n) map.set(i, object[i]); else while (++i &#x3c; n) map.set(f.call(object, o = object[i],
i), o);
  } else {
    for (var key in object) map.set(key, object[key]);
  }
  return map;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* that provides simple printing support for both single value and ranged filters.
* @method filterPrinter
* @memberof dc.baseMixin
* @instance
* @example
* // for a chart with an ordinal brush, print the filters in upper case
* chart.filterPrinter(function(filters) {
*   return filters.<span class="apidocCodeKeywordSpan">map</span>(function(f) { return f.toUpperCase(); }).join(&#x27;, &#x27;);
* });
* // for a chart with a range brush, print the filter as start and extent
* chart.filterPrinter(function(filters) {
*   return &#x27;start &#x27; + dc.utils.printSingleValue(filters[0][0]) +
*     &#x27; extent &#x27; + dc.utils.printSingleValue(filters[0][1] - filters[0][0]);
* });
* @param {Function} [filterPrinterFunction=dc.printers.filters]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.max" id="apidoc.element.dc.d3.max">
        function <span class="apidocSignatureSpan">dc.d3.</span>max
        <span class="apidocSignatureSpan">(array, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max = function (array, f) {
  var i = -1, n = array.length, a, b;
  if (arguments.length === 1) {
    while (++i &#x3c; n) if ((b = array[i]) != null &#x26;&#x26; b &#x3e;= b) {
      a = b;
      break;
    }
    while (++i &#x3c; n) if ((b = array[i]) != null &#x26;&#x26; b &#x3e; a) a = b;
  } else {
    while (++i &#x3c; n) if ((b = f.call(array, array[i], i)) != null &#x26;&#x26; b &#x3e;= b) {
      a = b;
      break;
    }
    while (++i &#x3c; n) if ((b = f.call(array, array[i], i)) != null &#x26;&#x26; b &#x3e; a) a = b;
  }
  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var f = filter;
var fromBottomLeft;

if (f[0] instanceof Array) {
    fromBottomLeft = [
        [Math.min(filter[0][0], filter[1][0]), Math.min(filter[0][1], filter[1][1])],
        [Math.<span class="apidocCodeKeywordSpan">max</span>(filter[0][0], filter[1][0]), Math.max(filter[0][1], filter[1][1])]
    ];
} else {
    fromBottomLeft = [[filter[0], -Infinity], [filter[1], Infinity]];
}

f.isFiltered = function (value) {
    var x, y;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.mean" id="apidoc.element.dc.d3.mean">
        function <span class="apidocSignatureSpan">dc.d3.</span>mean
        <span class="apidocSignatureSpan">(array, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mean = function (array, f) {
  var s = 0, n = array.length, a, i = -1, j = n;
  if (arguments.length === 1) {
    while (++i &#x3c; n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
  } else {
    while (++i &#x3c; n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
  }
  if (j) return s / j;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.median" id="apidoc.element.dc.d3.median">
        function <span class="apidocSignatureSpan">dc.d3.</span>median
        <span class="apidocSignatureSpan">(array, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">median = function (array, f) {
  var numbers = [], n = array.length, a, i = -1;
  if (arguments.length === 1) {
    while (++i &#x3c; n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
  } else {
    while (++i &#x3c; n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
  }
  if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.merge" id="apidoc.element.dc.d3.merge">
        function <span class="apidocSignatureSpan">dc.d3.</span>merge
        <span class="apidocSignatureSpan">(arrays)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function (arrays) {
  var n = arrays.length, m, i = -1, j = 0, merged, array;
  while (++i &#x3c; n) j += arrays[i].length;
  merged = new Array(j);
  while (--n &#x3e;= 0) {
    array = arrays[n];
    m = array.length;
    while (--m &#x3e;= 0) {
      merged[--j] = array[m];
    }
  }
  return merged;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  segments = [];
  polygon = [];
},
polygonEnd: function() {
  clip.point = point;
  clip.lineStart = lineStart;
  clip.lineEnd = lineEnd;
  segments = d3.<span class="apidocCodeKeywordSpan">merge</span>(segments);
  var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
  if (segments.length) {
    if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
    d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
  } else if (clipStartInside) {
    if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
    listener.lineStart();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.min" id="apidoc.element.dc.d3.min">
        function <span class="apidocSignatureSpan">dc.d3.</span>min
        <span class="apidocSignatureSpan">(array, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">min = function (array, f) {
  var i = -1, n = array.length, a, b;
  if (arguments.length === 1) {
    while (++i &#x3c; n) if ((b = array[i]) != null &#x26;&#x26; b &#x3e;= b) {
      a = b;
      break;
    }
    while (++i &#x3c; n) if ((b = array[i]) != null &#x26;&#x26; a &#x3e; b) a = b;
  } else {
    while (++i &#x3c; n) if ((b = f.call(array, array[i], i)) != null &#x26;&#x26; b &#x3e;= b) {
      a = b;
      break;
    }
    while (++i &#x3c; n) if ((b = f.call(array, array[i], i)) != null &#x26;&#x26; a &#x3e; b) a = b;
  }
  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (filter === null) { return null; }

var f = filter;
var fromBottomLeft;

if (f[0] instanceof Array) {
    fromBottomLeft = [
        [Math.<span class="apidocCodeKeywordSpan">min</span>(filter[0][0], filter[1][0]), Math.min(filter[0][1], filter[1][1])],
        [Math.max(filter[0][0], filter[1][0]), Math.max(filter[0][1], filter[1][1])]
    ];
} else {
    fromBottomLeft = [[filter[0], -Infinity], [filter[1], Infinity]];
}

f.isFiltered = function (value) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.mouse" id="apidoc.element.dc.d3.mouse">
        function <span class="apidocSignatureSpan">dc.d3.</span>mouse
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mouse = function (container) {
  return d3_mousePoint(container, d3_eventSource());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        .attr(&#x27;y&#x27;, 20);

    debugG
        .append(&#x27;rect&#x27;)
        .attr(&#x27;width&#x27;, _chart.width())
        .attr(&#x27;height&#x27;, _chart.height())
        .on(&#x27;mousemove&#x27;, function () {
            var position = d3.<span class="apidocCodeKeywordSpan">mouse</span>(debugG.node());
            var msg = position[0] + &#x27;, &#x27; + position[1];
            debugText.text(msg);
        });
} else {
    _chart.selectAll(&#x27;.debug&#x27;).remove();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.nest" id="apidoc.element.dc.d3.nest">
        function <span class="apidocSignatureSpan">dc.d3.</span>nest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nest = function () {
  var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
  function map(mapType, array, depth) {
    if (depth &#x3e;= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
    var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
    while (++i &#x3c; n) {
      if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
        values.push(object);
      } else {
        valuesByKey.set(keyValue, [ object ]);
      }
    }
    if (mapType) {
      object = mapType();
      setter = function(keyValue, values) {
        object.set(keyValue, map(mapType, values, depth));
      };
    } else {
      object = {};
      setter = function(keyValue, values) {
        object[keyValue] = map(mapType, values, depth);
      };
    }
    valuesByKey.forEach(setter);
    return object;
  }
  function entries(map, depth) {
    if (depth &#x3e;= keys.length) return map;
    var array = [], sortKey = sortKeys[depth++];
    map.forEach(function(key, keyMap) {
      array.push({
        key: key,
        values: entries(keyMap, depth)
      });
    });
    return sortKey ? array.sort(function(a, b) {
      return sortKey(a.key, b.key);
    }) : array;
  }
  nest.map = function(array, mapType) {
    return map(mapType, array, 0);
  };
  nest.entries = function(array) {
    return entries(map(d3.map, array, 0), 0);
  };
  nest.key = function(d) {
    keys.push(d);
    return nest;
  };
  nest.sortKeys = function(order) {
    sortKeys[keys.length - 1] = order;
    return nest;
  };
  nest.sortValues = function(order) {
    sortValues = order;
    return nest;
  };
  nest.rollup = function(f) {
    rollup = f;
    return nest;
  };
  return nest;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var entries;
    if (_order === d3.ascending) {
        entries = _chart.dimension().bottom(_size);
    } else {
        entries = _chart.dimension().top(_size);
    }

    return d3.<span class="apidocCodeKeywordSpan">nest</span>()
        .key(_chart.group())
        .sortKeys(_order)
        .entries(entries.sort(function (a, b) {
            return _order(_sortBy(a), _sortBy(b));
        }).slice(_beginSlice, _endSlice));
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.pairs" id="apidoc.element.dc.d3.pairs">
        function <span class="apidocSignatureSpan">dc.d3.</span>pairs
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pairs = function (array) {
  var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n &#x3c; 0 ? 0 : n);
  while (i &#x3c; n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
  return pairs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.permute" id="apidoc.element.dc.d3.permute">
        function <span class="apidocSignatureSpan">dc.d3.</span>permute
        <span class="apidocSignatureSpan">(array, indexes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">permute = function (array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
var points = series.map(function(d) {
  return d.map(function(v, i) {
    return [ x.call(stack, v, i), y.call(stack, v, i) ];
  });
});
var orders = order.call(stack, points, index);
series = d3.<span class="apidocCodeKeywordSpan">permute</span>(series, orders);
points = d3.permute(points, orders);
var offsets = offset.call(stack, points, index);
var m = series[0].length, n, i, j, o;
for (j = 0; j &#x3c; m; ++j) {
  out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
  for (i = 1; i &#x3c; n; ++i) {
    out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.quantile" id="apidoc.element.dc.d3.quantile">
        function <span class="apidocSignatureSpan">dc.d3.</span>quantile
        <span class="apidocSignatureSpan">(values, p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">quantile = function (values, p) {
  var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
  return e ? v + e * (values[h] - v) : v;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    function boxWhiskers (d) {
        return [0, d.length - 1];
    }

    function boxQuartiles (d) {
        return [
            d3.<span class="apidocCodeKeywordSpan">quantile</span>(d, 0.25),
            d3.quantile(d, 0.5),
            d3.quantile(d, 0.75)
        ];
    }

})();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.range" id="apidoc.element.dc.d3.range">
        function <span class="apidocSignatureSpan">dc.d3.</span>range
        <span class="apidocSignatureSpan">(start, stop, step)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">range = function (start, stop, step) {
  if (arguments.length &#x3c; 3) {
    step = 1;
    if (arguments.length &#x3c; 2) {
      stop = start;
      start = 0;
    }
  }
  if ((stop - start) / step === Infinity) throw new Error(&#x22;infinite range&#x22;);
  var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
  start *= k, stop *= k, step *= k;
  if (step &#x3c; 0) while ((j = start + step * ++i) &#x3e; stop) range.push(j / k); else while ((j = start + step * ++i) &#x3c; stop) range.push
(j / k);
  return range;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @memberof dc.colorMixin
* @instance
* @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Scales.md d3.scale}
* @example
* // alternate categorical scale
* chart.colors(d3.scale.category20b());
* // ordinal scale
* chart.colors(d3.scale.ordinal().<span class="apidocCodeKeywordSpan">range</span>([&#x27;red&#x27;,&#x27;green&#x27;,&#x27;blue
&#x27;]));
* // convenience method, the same as above
* chart.ordinalColors([&#x27;red&#x27;,&#x27;green&#x27;,&#x27;blue&#x27;]);
* // set a linear scale
* chart.linearColors([&#x22;#4575b4&#x22;, &#x22;#ffffbf&#x22;, &#x22;#a50026&#x22;]);
* @param {d3.scale} [colorScale=d3.scale.category20c()]
* @returns {d3.scale|dc.colorMixin}
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.rebind" id="apidoc.element.dc.d3.rebind">
        function <span class="apidocSignatureSpan">dc.d3.</span>rebind
        <span class="apidocSignatureSpan">(target, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rebind = function (target, source) {
  var i = 1, n = arguments.length, method;
  while (++i &#x3c; n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
  return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };
  }
  drag.origin = function(x) {
    if (!arguments.length) return origin;
    origin = x;
    return drag;
  };
  return d3.<span class="apidocCodeKeywordSpan">rebind</span>(drag, event, &#x22;on&#x22;);
};
function d3_behavior_dragTouchId() {
  return d3.event.changedTouches[0].identifier;
}
d3.touches = function(container, touches) {
  if (arguments.length &#x3c; 2) touches = d3_eventSource().touches;
  return touches ? d3_array(touches).map(function(touch) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.requote" id="apidoc.element.dc.d3.requote">
        function <span class="apidocSignatureSpan">dc.d3.</span>requote
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">requote = function (s) {
  return s.replace(d3_requote_re, &#x22;\\$&#x26;&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    for (value in name) this.each(d3_selection_classed(value, name[value]));
    return this;
  }
  return this.each(d3_selection_classed(name, value));
};
function d3_selection_classedRe(name) {
  return new RegExp(&#x22;(?:^|\\s+)&#x22; + d3.<span class="apidocCodeKeywordSpan">requote</span>(name) + &#x22;(?:\\s+|$)&#x22
;, &#x22;g&#x22;);
}
function d3_selection_classes(name) {
  return (name + &#x22;&#x22;).trim().split(/^|\s+/);
}
function d3_selection_classed(name, value) {
  name = d3_selection_classes(name).map(d3_selection_classedName);
  var n = name.length;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.rgb" id="apidoc.element.dc.d3.rgb">
        function <span class="apidocSignatureSpan">dc.d3.</span>rgb
        <span class="apidocSignatureSpan">(r, g, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function d3_rgb(r, g, b) {
  return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length &#x3c; 2 ? r instanceof d3_rgb ?
new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse(&#x22;&#x22; + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return d3.rebind(zoom, event, &#x22;on&#x22;);
};
var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
d3.color = d3_color;
function d3_color() {}
d3_color.prototype.toString = function() {
  return this.<span class="apidocCodeKeywordSpan">rgb</span>() + &#x22;&#x22;;
};
d3.hsl = d3_hsl;
function d3_hsl(h, s, l) {
  return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length &#x3c; 2 ? h instanceof d3_hsl
 ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse(&#x22;&#x22; + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
}
var d3_hslPrototype = d3_hsl.prototype = new d3_color();
d3_hslPrototype.brighter = function(k) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.round" id="apidoc.element.dc.d3.round">
        function <span class="apidocSignatureSpan">dc.d3.</span>round
        <span class="apidocSignatureSpan">(x, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">round = function (x, n) {
  return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
dc.round.floor = function (n) {
    return Math.floor(n);
};
dc.round.ceil = function (n) {
    return Math.ceil(n);
};
dc.round.round = function (n) {
    return Math.<span class="apidocCodeKeywordSpan">round</span>(n);
};

dc.override = function (obj, functionName, newFunction) {
    var existingFunction = obj[functionName];
    obj[&#x27;_&#x27; + functionName] = existingFunction;
    obj[functionName] = newFunction;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.select" id="apidoc.element.dc.d3.select">
        function <span class="apidocSignatureSpan">dc.d3.</span>select
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">select = function (node) {
  var group;
  if (typeof node === &#x22;string&#x22;) {
    group = [ d3_select(node, d3_document) ];
    group.parentNode = d3_document.documentElement;
  } else {
    group = [ node ];
    group.parentNode = d3_documentElement(node);
  }
  return d3_selection([ group ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {d3.selection} parent
 * @param {String} selector
 * @param {String} tag
 * @returns {d3.selection}
 */
dc.utils.appendOrSelect = function (parent, selector, tag) {
    tag = tag || selector;
    var element = parent.<span class="apidocCodeKeywordSpan">select</span>(selector);
    if (element.empty()) {
        element = parent.append(tag);
    }
    return element;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.selectAll" id="apidoc.element.dc.d3.selectAll">
        function <span class="apidocSignatureSpan">dc.d3.</span>selectAll
        <span class="apidocSignatureSpan">(nodes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectAll = function (nodes) {
  var group;
  if (typeof nodes === &#x22;string&#x22;) {
    group = d3_array(d3_selectAll(nodes, d3_document));
    group.parentNode = d3_document.documentElement;
  } else {
    group = d3_array(nodes);
    group.parentNode = null;
  }
  return d3_selection([ group ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @example
 * var xPosition = dc.pluck(&#x27;x&#x27;, function (x, i) {
 *     // `this` is the original datum,
 *     // `x` is the x property of the datum,
 *     // `i` is the position in the array
 *     return this.radius + x;
 * });
 * dc.<span class="apidocCodeKeywordSpan">selectAll</span>(&#x27;.circle&#x27;).data(...).x(xPosition);
 * @param {String} n
 * @param {Function} [f]
 * @returns {Function}
 */
dc.pluck = function (n, f) {
if (!f) {
    return function (d) { return d[n]; };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.selection" id="apidoc.element.dc.d3.selection">
        function <span class="apidocSignatureSpan">dc.d3.</span>selection
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selection = function () {
  return d3.select(d3_document.documentElement);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
d3_transitionPrototype.call = d3_selectionPrototype.call;
d3_transitionPrototype.empty = d3_selectionPrototype.empty;
d3_transitionPrototype.node = d3_selectionPrototype.node;
d3_transitionPrototype.size = d3_selectionPrototype.size;
d3.transition = function(selection, name) {
  return selection &#x26;&#x26; selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.<span
 class="apidocCodeKeywordSpan">selection</span>().transition(selection);
};
d3.transition.prototype = d3_transitionPrototype;
d3_transitionPrototype.select = function(selector) {
  var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
  selector = d3_selection_selector(selector);
  for (var j = -1, m = this.length; ++j &#x3c; m; ) {
    subgroups.push(subgroup = []);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.set" id="apidoc.element.dc.d3.set">
        function <span class="apidocSignatureSpan">dc.d3.</span>set
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (array) {
  var set = new d3_Set();
  if (array) for (var i = 0, n = array.length; i &#x3c; n; ++i) set.add(array[i]);
  return set;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    function domainFilter () {
if (!_chart.x()) {
    return d3.functor(true);
}
var xDomain = _chart.x().domain();
if (_chart.isOrdinal()) {
    // TODO #416
    //var domainSet = d3.<span class="apidocCodeKeywordSpan">set</span>(xDomain);
    return function () {
        return true; //domainSet.has(p.x);
    };
}
if (_chart.elasticX()) {
    return function () { return true; };
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.shuffle" id="apidoc.element.dc.d3.shuffle">
        function <span class="apidocSignatureSpan">dc.d3.</span>shuffle
        <span class="apidocSignatureSpan">(array, i0, i1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shuffle = function (array, i0, i1) {
  if ((m = arguments.length) &#x3c; 3) {
    i1 = array.length;
    if (m &#x3c; 2) i0 = 0;
  }
  var m = i1 - i0, t, i;
  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
  }
  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.sum" id="apidoc.element.dc.d3.sum">
        function <span class="apidocSignatureSpan">dc.d3.</span>sum
        <span class="apidocSignatureSpan">(array, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sum = function (array, f) {
  var s = 0, n = array.length, a, i = -1;
  if (arguments.length === 1) {
    while (++i &#x3c; n) if (d3_numeric(a = +array[i])) s += a;
  } else {
    while (++i &#x3c; n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
  }
  return s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
dc.capMixin = function (_chart) {

var _cap = Infinity;

var _othersLabel = &#x27;Others&#x27;;

var _othersGrouper = function (topRows) {
    var topRowsSum = d3.<span class="apidocCodeKeywordSpan">sum</span>(topRows, _chart.valueAccessor()),
        allRows = _chart.group().all(),
        allRowsSum = d3.sum(allRows, _chart.valueAccessor()),
        topKeys = topRows.map(_chart.keyAccessor()),
        allKeys = allRows.map(_chart.keyAccessor()),
        topSet = d3.set(topKeys),
        others = allKeys.filter(function (d) {return !topSet.has(d);});
    if (allRowsSum &#x3e; topRowsSum) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.text" id="apidoc.element.dc.d3.text">
        function <span class="apidocSignatureSpan">dc.d3.</span>text
        <span class="apidocSignatureSpan">(url, mimeType, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">text = function (url, mimeType, callback) {
  if (arguments.length === 2 &#x26;&#x26; typeof mimeType === &#x22;function&#x22;) callback = mimeType,
  mimeType = null;
  return d3_xhr(url, mimeType, response, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @instance
 * @returns {dc.baseMixin}
 */
_chart.turnOnControls = function () {
    if (_root) {
        var attribute = _chart.controlsUseVisibility() ? &#x27;visibility&#x27; : &#x27;display&#x27;;
        _chart.selectAll(&#x27;.reset&#x27;).style(attribute, null);
        _chart.selectAll(&#x27;.filter&#x27;).<span class="apidocCodeKeywordSpan">text</span>(_filterPrinter(_chart.filters())).
style(attribute, null);
    }
    return _chart;
};

/**
 * Turn off optional control elements within the root element.
 * @method turnOffControls
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.timer" id="apidoc.element.dc.d3.timer">
        function <span class="apidocSignatureSpan">dc.d3.</span>timer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timer = function () {
  d3_timer.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.touch" id="apidoc.element.dc.d3.touch">
        function <span class="apidocSignatureSpan">dc.d3.</span>touch
        <span class="apidocSignatureSpan">(container, touches, identifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">touch = function (container, touches, identifier) {
  if (arguments.length &#x3c; 3) identifier = touches, touches = d3_eventSource().changedTouches;
  if (touches) for (var i = 0, n = touches.length, touch; i &#x3c; n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return d3_mousePoint(container, touch);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.touches" id="apidoc.element.dc.d3.touches">
        function <span class="apidocSignatureSpan">dc.d3.</span>touches
        <span class="apidocSignatureSpan">(container, touches)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">touches = function (container, touches) {
  if (arguments.length &#x3c; 2) touches = d3_eventSource().touches;
  return touches ? d3_array(touches).map(function(touch) {
    var point = d3_mousePoint(container, touch);
    point.identifier = touch.identifier;
    return point;
  }) : [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
function touchstarted() {
  var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = &#x22;.zoom-&#x22; +
d3.event.changedTouches[0].identifier, touchmove = &#x22;touchmove&#x22; + zoomName, touchend = &#x22;touchend&#x22; + zoomName,
targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
  started();
  zoomstarted(dispatch);
  subject.on(mousedown, null).on(touchstart, started);
  function relocate() {
    var touches = d3.<span class="apidocCodeKeywordSpan">touches</span>(that);
    scale0 = view.k;
    touches.forEach(function(t) {
      if (t.identifier in locations0) locations0[t.identifier] = location(t);
    });
    return touches;
  }
  function started() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.transform" id="apidoc.element.dc.d3.transform">
        function <span class="apidocSignatureSpan">dc.d3.</span>transform
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transform = function (string) {
  var g = d3_document.createElementNS(d3.ns.prefix.svg, &#x22;g&#x22;);
  return (d3.transform = function(string) {
    if (string != null) {
      g.setAttribute(&#x22;transform&#x22;, string);
      var t = g.transform.baseVal.consolidate();
    }
    return new d3_transform(t ? t.matrix : d3_transformIdentity);
  })(string);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
  } else if (kb[0] !== 1 || kb[1] !== 1) {
    s.push(d3_interpolateTransformPop(s) + &#x22;scale(&#x22; + kb + &#x22;)&#x22;);
  }
}
function d3_interpolateTransform(a, b) {
  var s = [], q = [];
  a = d3.<span class="apidocCodeKeywordSpan">transform</span>(a), b = d3.transform(b);
  d3_interpolateTranslate(a.translate, b.translate, s, q);
  d3_interpolateRotate(a.rotate, b.rotate, s, q);
  d3_interpolateSkew(a.skew, b.skew, s, q);
  d3_interpolateScale(a.scale, b.scale, s, q);
  a = b = null;
  return function(t) {
    var i = -1, n = q.length, o;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.transition" id="apidoc.element.dc.d3.transition">
        function <span class="apidocSignatureSpan">dc.d3.</span>transition
        <span class="apidocSignatureSpan">(selection, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transition = function (selection, name) {
  return selection &#x26;&#x26; selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition
(selection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {d3.transition|d3.selection}
 */
dc.transition = function (selection, duration, delay, name) {
if (dc.disableTransitions || duration &#x3c;= 0) {
    return selection;
}

var s = selection.<span class="apidocCodeKeywordSpan">transition</span>(name);

if (duration &#x3e;= 0 || duration !== undefined) {
    s = s.duration(duration);
}
if (delay &#x3e;= 0 || delay !== undefined) {
    s = s.delay(delay);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.transpose" id="apidoc.element.dc.d3.transpose">
        function <span class="apidocSignatureSpan">dc.d3.</span>transpose
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transpose = function (matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i &#x3c; m; ) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j &#x3c; n; ) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return transpose;
};
function d3_transposeLength(d) {
  return d.length;
}
d3.zip = function() {
  return d3.<span class="apidocCodeKeywordSpan">transpose</span>(arguments);
};
d3.keys = function(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
};
d3.values = function(map) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.tsv" id="apidoc.element.dc.d3.tsv">
        function <span class="apidocSignatureSpan">dc.d3.</span>tsv
        <span class="apidocSignatureSpan">(url, row, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dsv(url, row, callback) {
  if (arguments.length &#x3c; 3) callback = row, row = null;
  var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
  xhr.row = function(_) {
    return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
  };
  return xhr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.values" id="apidoc.element.dc.d3.values">
        function <span class="apidocSignatureSpan">dc.d3.</span>values
        <span class="apidocSignatureSpan">(map)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">values = function (map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    layer.values = layer.values.filter(domainFilter());
    return layer.values;
}

var _stackLayout = d3.layout.stack()
    .<span class="apidocCodeKeywordSpan">values</span>(prepareValues);

var _stack = [];
var _titles = {};

var _hidableStacks = false;

function domainFilter () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.variance" id="apidoc.element.dc.d3.variance">
        function <span class="apidocSignatureSpan">dc.d3.</span>variance
        <span class="apidocSignatureSpan">(array, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">variance = function (array, f) {
  var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
  if (arguments.length === 1) {
    while (++i &#x3c; n) {
      if (d3_numeric(a = d3_number(array[i]))) {
        d = a - m;
        m += d / ++j;
        s += d * (a - m);
      }
    }
  } else {
    while (++i &#x3c; n) {
      if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
        d = a - m;
        m += d / ++j;
        s += d * (a - m);
      }
    }
  }
  if (j &#x3e; 1) return s / (j - 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.xhr" id="apidoc.element.dc.d3.xhr">
        function <span class="apidocSignatureSpan">dc.d3.</span>xhr
        <span class="apidocSignatureSpan">(url, mimeType, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">xhr = function (url, mimeType, callback) {
  if (arguments.length === 2 &#x26;&#x26; typeof mimeType === &#x22;function&#x22;) callback = mimeType,
  mimeType = null;
  return d3_xhr(url, mimeType, response, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.xml" id="apidoc.element.dc.d3.xml">
        function <span class="apidocSignatureSpan">dc.d3.</span>xml
        <span class="apidocSignatureSpan">(url, mimeType, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">xml = function (url, mimeType, callback) {
  if (arguments.length === 2 &#x26;&#x26; typeof mimeType === &#x22;function&#x22;) callback = mimeType,
  mimeType = null;
  return d3_xhr(url, mimeType, response, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.d3.zip" id="apidoc.element.dc.d3.zip">
        function <span class="apidocSignatureSpan">dc.d3.</span>zip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zip = function () {
  return d3.transpose(arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.dc.dc" id="apidoc.module.dc.dc">module dc.dc</a></h1>




    <h2>
        <a href="#apidoc.element.dc.dc.abstractBubbleChart" id="apidoc.element.dc.dc.abstractBubbleChart">
        function <span class="apidocSignatureSpan">dc.dc.</span>abstractBubbleChart
        <span class="apidocSignatureSpan">(_chart)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">abstractBubbleChart = function (_chart) {
    var _maxBubbleRelativeSize = 0.3;
    var _minRadiusWithLabel = 10;

    _chart.BUBBLE_NODE_CLASS = &#x27;node&#x27;;
    _chart.BUBBLE_CLASS = &#x27;bubble&#x27;;
    _chart.MIN_RADIUS = 10;

    _chart = dc.colorMixin(_chart);

    _chart.renderLabel(true);

    _chart.data(function (group) {
        return group.top(Infinity);
    });

    var _r = d3.scale.linear().domain([0, 100]);

    var _rValueAccessor = function (d) {
        return d.r;
    };

<span class="apidocCodeCommentSpan">    /**
     * Get or set the bubble radius scale. By default the bubble chart uses
     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Quantitative-Scales.md#linear d3.scale.linear().domain([0,
100])}
     * as its radius scale.
     * @method r
     * @memberof dc.bubbleMixin
     * @instance
     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Scales.md d3.scale}
     * @param {d3.scale} [bubbleRadiusScale=d3.scale.linear().domain([0, 100])]
     * @returns {d3.scale|dc.bubbleMixin}
     */
</span>    _chart.r = function (bubbleRadiusScale) {
        if (!arguments.length) {
            return _r;
        }
        _r = bubbleRadiusScale;
        return _chart;
    };

    /**
     * Get or set the radius value accessor function. If set, the radius value accessor function will
     * be used to retrieve a data value for each bubble. The data retrieved then will be mapped using
     * the r scale to the actual bubble radius. This allows you to encode a data dimension using bubble
     * size.
     * @method radiusValueAccessor
     * @memberof dc.bubbleMixin
     * @instance
     * @param {Function} [radiusValueAccessor]
     * @returns {Function|dc.bubbleMixin}
     */
    _chart.radiusValueAccessor = function (radiusValueAccessor) {
        if (!arguments.length) {
            return _rValueAccessor;
        }
        _rValueAccessor = radiusValueAccessor;
        return _chart;
    };

    _chart.rMin = function () {
        var min = d3.min(_chart.data(), function (e) {
            return _chart.radiusValueAccessor()(e);
        });
        return min;
    };

    _chart.rMax = function () {
        var max = d3.max(_chart.data(), function (e) {
            return _chart.radiusValueAccessor()(e);
        });
        return max;
    };

    _chart.bubbleR = function (d) {
        var value = _chart.radiusValueAccessor()(d);
        var r = _chart.r()(value);
        if (isNaN(r) || value &#x3c;= 0) {
            r = 0;
        }
        return r;
    };

    var labelFunction = function (d) {
        return _chart.label()(d);
    };

    var shouldLabel = function (d) {
        return (_chart.bubbleR(d) &#x3e; _minRadiusWithLabel);
    };

    var labelOpacity = function (d) {
        return shouldLabel(d) ? 1 : 0;
    };

    var labelPointerEvent = function (d) {
        return shouldLabel(d) ? &#x27;all&#x27; : &#x27;none&#x27;;
    };

    _chart._doRenderLabel = function (bubbleGEnter) {
        if (_chart.renderLabel()) {
            var label = bubbleGEnter.select(&#x27;text&#x27;);

            if (label.empty()) {
                label = bubbleGEnter.append(&#x27;text&#x27;)
                    .attr(&#x27;text-anchor&#x27;, &#x27;middle&#x27;)
                    .attr(&#x27;dy&#x27;, &#x27;.3em&#x27;)
                    .on(&#x27;click&#x27;, _chart.onClick);
            }

            label
                .attr(&#x27;opacity&#x27;, 0)
                .attr(&#x27;pointer-events&#x27;, labelPointerEvent)
                .text(labelFunction);
            dc.transition(label, _chart.transitionDuration(), _chart.transitionDelay())
                .attr(&#x27;opacity&#x27;, labelOpacity);
        }
    };

    _chart.doUpdateLabels = function (bubbleGEnter) {
        if (_chart.renderLabel()) {
            var labels = bubbleGEnter.select(&#x27;text&#x27;)
                .attr(&#x27;pointer-events&#x27;, labelPointerEvent)
                .text(labelFunction);
            dc.transition(labels, _chart.transitionDuration(), _chart.transitionDelay())
                .attr(&#x27;opacity&#x27;, labelOpacity);
        }
    };

    var titleFunction = function (d) {
        return _chart.title()(d);
    };

    _chart._doRenderTitles = function (g) {
        if (_chart.renderTitle()) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.afterTransition" id="apidoc.element.dc.dc.afterTransition">
        function <span class="apidocSignatureSpan">dc.dc.</span>afterTransition
        <span class="apidocSignatureSpan">(transition, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterTransition = function (transition, callback) {
    if (transition.empty() || !transition.duration) {
        callback.call(transition);
    } else {
        var n = 0;
        transition
            .each(function () { ++n; })
            .each(&#x27;end&#x27;, function () {
                if (!--n) {
                    callback.call(transition);
                }
            });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.barChart" id="apidoc.element.dc.dc.barChart">
        function <span class="apidocSignatureSpan">dc.dc.</span>barChart
        <span class="apidocSignatureSpan">(parent, chartGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">barChart = function (parent, chartGroup) {
    var MIN_BAR_WIDTH = 1;
    var DEFAULT_GAP_BETWEEN_BARS = 2;
    var LABEL_PADDING = 3;

    var _chart = dc.stackMixin(dc.coordinateGridMixin({}));

    var _gap = DEFAULT_GAP_BETWEEN_BARS;
    var _centerBar = false;
    var _alwaysUseRounding = false;

    var _barWidth;

    dc.override(_chart, &#x27;rescale&#x27;, function () {
        _chart._rescale();
        _barWidth = undefined;
        return _chart;
    });

    dc.override(_chart, &#x27;render&#x27;, function () {
        if (_chart.round() &#x26;&#x26; _centerBar &#x26;&#x26; !_alwaysUseRounding) {
            dc.logger.warn(&#x27;By default, brush rounding is disabled if bars are centered. &#x27; +
                         &#x27;See dc.js bar chart API documentation for details.&#x27;);
        }

        return _chart._render();
    });

    _chart.label(function (d) {
        return dc.utils.printSingleValue(d.y0 + d.y);
    }, false);

    _chart.plotData = function () {
        var layers = _chart.chartBodyG().selectAll(&#x27;g.stack&#x27;)
            .data(_chart.data());

        calculateBarWidth();

        layers
            .enter()
            .append(&#x27;g&#x27;)
            .attr(&#x27;class&#x27;, function (d, i) {
                return &#x27;stack &#x27; + &#x27;_&#x27; + i;
            });

        var last = layers.size() - 1;
        layers.each(function (d, i) {
            var layer = d3.select(this);

            renderBars(layer, i, d);

            if (_chart.renderLabel() &#x26;&#x26; last === i) {
                renderLabels(layer, i, d);
            }
        });
    };

    function barHeight (d) {
        return dc.utils.safeNumber(Math.abs(_chart.y()(d.y + d.y0) - _chart.y()(d.y0)));
    }

    function renderLabels (layer, layerIndex, d) {
        var labels = layer.selectAll(&#x27;text.barLabel&#x27;)
            .data(d.values, dc.pluck(&#x27;x&#x27;));

        labels.enter()
            .append(&#x27;text&#x27;)
            .attr(&#x27;class&#x27;, &#x27;barLabel&#x27;)
            .attr(&#x27;text-anchor&#x27;, &#x27;middle&#x27;);

        if (_chart.isOrdinal()) {
            labels.on(&#x27;click&#x27;, _chart.onClick);
            labels.attr(&#x27;cursor&#x27;, &#x27;pointer&#x27;);
        }

        dc.transition(labels, _chart.transitionDuration(), _chart.transitionDelay())
            .attr(&#x27;x&#x27;, function (d) {
                var x = _chart.x()(d.x);
                if (!_centerBar) {
                    x += _barWidth / 2;
                }
                return dc.utils.safeNumber(x);
            })
            .attr(&#x27;y&#x27;, function (d) {
                var y = _chart.y()(d.y + d.y0);

                if (d.y &#x3c; 0) {
                    y -= barHeight(d);
                }

                return dc.utils.safeNumber(y - LABEL_PADDING);
            })
            .text(function (d) {
                return _chart.label()(d);
            });

        dc.transition(labels.exit(), _chart.transitionDuration(), _chart.transitionDelay())
            .attr(&#x27;height&#x27;, 0)
            .remove();
    }

    function renderBars (layer, layerIndex, d) {
        var bars = layer.selectAll(&#x27;rect.bar&#x27;)
            .data(d.values, dc.pluck(&#x27;x&#x27;));

        var enter = bars.enter()
            .append(&#x27;rect&#x27;)
            .attr(&#x27;class&#x27;, &#x27;bar&#x27;)
            .attr(&#x27;fill&#x27;, dc.pluck(&#x27;data&#x27;, _chart.getColor))
            .attr(&#x27;y&#x27;, _chart.yAxisHeight())
            .attr(&#x27;height&#x27;, 0);

        if (_chart.renderTitle()) {
            enter.append(&#x27;title&#x27;).text(dc.pluck(&#x27;data&#x27;, _chart.title(d.name)));
        }

        if (_chart.isOrdinal()) {
            bars.on(&#x27;click&#x27;, _chart.onClick);
        }

        dc.transition(bars, _chart.transitionDuration(), _chart.transitionDelay())
            .attr(&#x27;x&#x27;, function (d) {
                var x = _chart.x()(d.x);
                if (_centerBar) {
                    x -= _barWidth / 2;
                }
                if (_chart.isOrdinal() &#x26;&#x26; _gap !== undefined) {
                    x += _gap / 2;
                }
                return dc.utils.safeNumber(x);
            })
            .attr(&#x27;y&#x27;, function (d) {
                var y = _chart.y()(d.y + d.y0);

                if (d.y &#x3c; 0) {
                    y -= barHeight(d);
                }

                r ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* - {@link http://dc-js.github.com/dc.js/crime/index.html Canadian City Crime Stats}
* @class barChart
* @memberof dc
* @mixes dc.stackMixin
* @mixes dc.coordinateGridMixin
* @example
* // create a bar chart under #chart-container1 element using the default global chart group
* var chart1 = dc.<span class="apidocCodeKeywordSpan">barChart</span>(&#x27;#chart-container1&#x27;);
* // create a bar chart under #chart-container2 element using chart group A
* var chart2 = dc.barChart(&#x27;#chart-container2&#x27;, &#x27;chartGroupA&#x27;);
* // create a sub-chart under a composite parent chart
* var chart3 = dc.barChart(compositeChart);
* @param {String|node|d3.selection|dc.compositeChart} parent - Any valid
* {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector}
* specifying a dom block element such as a div; or a dom element or d3 selection.  If the bar
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.baseChart" id="apidoc.element.dc.dc.baseChart">
        function <span class="apidocSignatureSpan">dc.dc.</span>baseChart
        <span class="apidocSignatureSpan">(_chart)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">baseChart = function (_chart) {
    _chart.__dcFlag__ = dc.utils.uniqueId();

    var _dimension;
    var _group;

    var _anchor;
    var _root;
    var _svg;
    var _isChild;

    var _minWidth = 200;
    var _defaultWidthCalc = function (element) {
        var width = element &#x26;&#x26; element.getBoundingClientRect &#x26;&#x26; element.getBoundingClientRect().width;
        return (width &#x26;&#x26; width &#x3e; _minWidth) ? width : _minWidth;
    };
    var _widthCalc = _defaultWidthCalc;

    var _minHeight = 200;
    var _defaultHeightCalc = function (element) {
        var height = element &#x26;&#x26; element.getBoundingClientRect &#x26;&#x26; element.getBoundingClientRect().height;
        return (height &#x26;&#x26; height &#x3e; _minHeight) ? height : _minHeight;
    };
    var _heightCalc = _defaultHeightCalc;
    var _width, _height;

    var _keyAccessor = dc.pluck(&#x27;key&#x27;);
    var _valueAccessor = dc.pluck(&#x27;value&#x27;);
    var _label = dc.pluck(&#x27;key&#x27;);

    var _ordering = dc.pluck(&#x27;key&#x27;);
    var _orderSort;

    var _renderLabel = false;

    var _title = function (d) {
        return _chart.keyAccessor()(d) + &#x27;: &#x27; + _chart.valueAccessor()(d);
    };
    var _renderTitle = true;
    var _controlsUseVisibility = false;

    var _transitionDuration = 750;

    var _transitionDelay = 0;

    var _filterPrinter = dc.printers.filters;

    var _mandatoryAttributes = [&#x27;dimension&#x27;, &#x27;group&#x27;];

    var _chartGroup = dc.constants.DEFAULT_CHART_GROUP;

    var _listeners = d3.dispatch(
        &#x27;preRender&#x27;,
        &#x27;postRender&#x27;,
        &#x27;preRedraw&#x27;,
        &#x27;postRedraw&#x27;,
        &#x27;filtered&#x27;,
        &#x27;zoomed&#x27;,
        &#x27;renderlet&#x27;,
        &#x27;pretransition&#x27;);

    var _legend;
    var _commitHandler;

    var _filters = [];
    var _filterHandler = function (dimension, filters) {
        if (filters.length === 0) {
            dimension.filter(null);
        } else if (filters.length === 1 &#x26;&#x26; !filters[0].isFiltered) {
            // single value and not a function-based filter
            dimension.filterExact(filters[0]);
        } else if (filters.length === 1 &#x26;&#x26; filters[0].filterType === &#x27;RangedFilter&#x27;) {
            // single range-based filter
            dimension.filterRange(filters[0]);
        } else {
            dimension.filterFunction(function (d) {
                for (var i = 0; i &#x3c; filters.length; i++) {
                    var filter = filters[i];
                    if (filter.isFiltered &#x26;&#x26; filter.isFiltered(d)) {
                        return true;
                    } else if (filter &#x3c;= d &#x26;&#x26; filter &#x3e;= d) {
                        return true;
                    }
                }
                return false;
            });
        }
        return filters;
    };

    var _data = function (group) {
        return group.all();
    };

    /**
     * Set or get the height attribute of a chart. The height is applied to the SVGElement generated by
     * the chart when rendered (or re-rendered). If a value is given, then it will be used to calculate
     * the new height and the chart returned for method chaining.  The value can either be a numeric, a
     * function, or falsy. If no value is specified then the value of the current height attribute will
     * be returned.
     *
     * By default, without an explicit height being given, the chart will select the width of its
     * anchor element. If that isn&#x27;t possible it defaults to 200 (provided by the
     * {@link dc.baseMixin#minHeight minHeight} property). Setting the value falsy will return
     * the chart to the default behavior.
     * @method height
     * @memberof dc.baseMixin
     * @instance
     * @see {@link dc.baseMixin#minHeight minHeight}
     * @example
     * // Default height
     * chart.height(function (element) {
     *     var height = element &#x26;&#x26; element.getBoundingClientRect &#x26;&#x26; element.getBoundingClientRect().height;
     *     return (height &#x26;&#x26; height &#x3e; chart.minHeight()) ? height : chart.minHeight();
     * });
     *
     * chart.height(250); // Set the chart&#x27;s height to 250px;
     * chart.height(function(anchor) { return doSomethingWith(anchor); }); // set the chart&#x27;s height with a function ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.baseMixin" id="apidoc.element.dc.dc.baseMixin">
        function <span class="apidocSignatureSpan">dc.dc.</span>baseMixin
        <span class="apidocSignatureSpan">(_chart)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">baseMixin = function (_chart) {
    _chart.__dcFlag__ = dc.utils.uniqueId();

    var _dimension;
    var _group;

    var _anchor;
    var _root;
    var _svg;
    var _isChild;

    var _minWidth = 200;
    var _defaultWidthCalc = function (element) {
        var width = element &#x26;&#x26; element.getBoundingClientRect &#x26;&#x26; element.getBoundingClientRect().width;
        return (width &#x26;&#x26; width &#x3e; _minWidth) ? width : _minWidth;
    };
    var _widthCalc = _defaultWidthCalc;

    var _minHeight = 200;
    var _defaultHeightCalc = function (element) {
        var height = element &#x26;&#x26; element.getBoundingClientRect &#x26;&#x26; element.getBoundingClientRect().height;
        return (height &#x26;&#x26; height &#x3e; _minHeight) ? height : _minHeight;
    };
    var _heightCalc = _defaultHeightCalc;
    var _width, _height;

    var _keyAccessor = dc.pluck(&#x27;key&#x27;);
    var _valueAccessor = dc.pluck(&#x27;value&#x27;);
    var _label = dc.pluck(&#x27;key&#x27;);

    var _ordering = dc.pluck(&#x27;key&#x27;);
    var _orderSort;

    var _renderLabel = false;

    var _title = function (d) {
        return _chart.keyAccessor()(d) + &#x27;: &#x27; + _chart.valueAccessor()(d);
    };
    var _renderTitle = true;
    var _controlsUseVisibility = false;

    var _transitionDuration = 750;

    var _transitionDelay = 0;

    var _filterPrinter = dc.printers.filters;

    var _mandatoryAttributes = [&#x27;dimension&#x27;, &#x27;group&#x27;];

    var _chartGroup = dc.constants.DEFAULT_CHART_GROUP;

    var _listeners = d3.dispatch(
        &#x27;preRender&#x27;,
        &#x27;postRender&#x27;,
        &#x27;preRedraw&#x27;,
        &#x27;postRedraw&#x27;,
        &#x27;filtered&#x27;,
        &#x27;zoomed&#x27;,
        &#x27;renderlet&#x27;,
        &#x27;pretransition&#x27;);

    var _legend;
    var _commitHandler;

    var _filters = [];
    var _filterHandler = function (dimension, filters) {
        if (filters.length === 0) {
            dimension.filter(null);
        } else if (filters.length === 1 &#x26;&#x26; !filters[0].isFiltered) {
            // single value and not a function-based filter
            dimension.filterExact(filters[0]);
        } else if (filters.length === 1 &#x26;&#x26; filters[0].filterType === &#x27;RangedFilter&#x27;) {
            // single range-based filter
            dimension.filterRange(filters[0]);
        } else {
            dimension.filterFunction(function (d) {
                for (var i = 0; i &#x3c; filters.length; i++) {
                    var filter = filters[i];
                    if (filter.isFiltered &#x26;&#x26; filter.isFiltered(d)) {
                        return true;
                    } else if (filter &#x3c;= d &#x26;&#x26; filter &#x3e;= d) {
                        return true;
                    }
                }
                return false;
            });
        }
        return filters;
    };

    var _data = function (group) {
        return group.all();
    };

    /**
     * Set or get the height attribute of a chart. The height is applied to the SVGElement generated by
     * the chart when rendered (or re-rendered). If a value is given, then it will be used to calculate
     * the new height and the chart returned for method chaining.  The value can either be a numeric, a
     * function, or falsy. If no value is specified then the value of the current height attribute will
     * be returned.
     *
     * By default, without an explicit height being given, the chart will select the width of its
     * anchor element. If that isn&#x27;t possible it defaults to 200 (provided by the
     * {@link dc.baseMixin#minHeight minHeight} property). Setting the value falsy will return
     * the chart to the default behavior.
     * @method height
     * @memberof dc.baseMixin
     * @instance
     * @see {@link dc.baseMixin#minHeight minHeight}
     * @example
     * // Default height
     * chart.height(function (element) {
     *     var height = element &#x26;&#x26; element.getBoundingClientRect &#x26;&#x26; element.getBoundingClientRect().height;
     *     return (height &#x26;&#x26; height &#x3e; chart.minHeight()) ? height : chart.minHeight();
     * });
     *
     * chart.height(250); // Set the chart&#x27;s height to 250px;
     * chart.height(function(anchor) { return doSomethingWith(anchor); }); // set the chart&#x27;s height with a function ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var GRID_LINE_CLASS = &#x27;grid-line&#x27;;
var HORIZONTAL_CLASS = &#x27;horizontal&#x27;;
var VERTICAL_CLASS = &#x27;vertical&#x27;;
var Y_AXIS_LABEL_CLASS = &#x27;y-axis-label&#x27;;
var X_AXIS_LABEL_CLASS = &#x27;x-axis-label&#x27;;
var DEFAULT_AXIS_LABEL_PADDING = 12;

_chart = dc.colorMixin(dc.marginMixin(dc.<span class="apidocCodeKeywordSpan">baseMixin</span>(_chart)));

_chart.colors(d3.scale.category10());
_chart._mandatoryAttributes().push(&#x27;x&#x27;);
var _parent;
var _g;
var _chartBodyG;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.boxPlot" id="apidoc.element.dc.dc.boxPlot">
        function <span class="apidocSignatureSpan">dc.dc.</span>boxPlot
        <span class="apidocSignatureSpan">(parent, chartGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">boxPlot = function (parent, chartGroup) {
    var _chart = dc.coordinateGridMixin({});

    // Returns a function to compute the interquartile range.
    function DEFAULT_WHISKERS_IQR (k) {
        return function (d) {
            var q1 = d.quartiles[0],
                q3 = d.quartiles[2],
                iqr = (q3 - q1) * k,
                i = -1,
                j = d.length;
            do { ++i; } while (d[i] &#x3c; q1 - iqr);
            do { --j; } while (d[j] &#x3e; q3 + iqr);
            return [i, j];
        };
    }

    var _whiskerIqrFactor = 1.5;
    var _whiskersIqr = DEFAULT_WHISKERS_IQR;
    var _whiskers = _whiskersIqr(_whiskerIqrFactor);

    var _box = d3.box();
    var _tickFormat = null;

    var _boxWidth = function (innerChartWidth, xUnits) {
        if (_chart.isOrdinal()) {
            return _chart.x().rangeBand();
        } else {
            return innerChartWidth / (1 + _chart.boxPadding()) / xUnits;
        }
    };

    // default padding to handle min/max whisker text
    _chart.yAxisPadding(12);

    // default to ordinal
    _chart.x(d3.scale.ordinal());
    _chart.xUnits(dc.units.ordinal);

    // valueAccessor should return an array of values that can be coerced into numbers
    // or if data is overloaded for a static array of arrays, it should be `Number`.
    // Empty arrays are not included.
    _chart.data(function (group) {
        return group.all().map(function (d) {
            d.map = function (accessor) { return accessor.call(d, d); };
            return d;
        }).filter(function (d) {
            var values = _chart.valueAccessor()(d);
            return values.length !== 0;
        });
    });

<span class="apidocCodeCommentSpan">    /**
     * Get or set the spacing between boxes as a fraction of box size. Valid values are within 0-1.
     * See the {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Ordinal-Scales.md#ordinal_rangeBands d3 docs}
     * for a visual description of how the padding is applied.
     * @method boxPadding
     * @memberof dc.boxPlot
     * @instance
     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Ordinal-Scales.md#ordinal_rangeBands d3.scale.ordinal.
rangeBands}
     * @param {Number} [padding=0.8]
     * @returns {Number|dc.boxPlot}
     */
</span>    _chart.boxPadding = _chart._rangeBandPadding;
    _chart.boxPadding(0.8);

    /**
     * Get or set the outer padding on an ordinal box chart. This setting has no effect on non-ordinal charts
     * or on charts with a custom {@link dc.boxPlot#boxWidth .boxWidth}. Will pad the width by
     * `padding * barWidth` on each side of the chart.
     * @method outerPadding
     * @memberof dc.boxPlot
     * @instance
     * @param {Number} [padding=0.5]
     * @returns {Number|dc.boxPlot}
     */
    _chart.outerPadding = _chart._outerRangeBandPadding;
    _chart.outerPadding(0.5);

    /**
     * Get or set the numerical width of the boxplot box. The width may also be a function taking as
     * parameters the chart width excluding the right and left margins, as well as the number of x
     * units.
     * @example
     * // Using numerical parameter
     * chart.boxWidth(10);
     * // Using function
     * chart.boxWidth((innerChartWidth, xUnits) { ... });
     * @method boxWidth
     * @memberof dc.boxPlot
     * @instance
     * @param {Number|Function} [boxWidth=0.5]
     * @returns {Number|Function|dc.boxPlot}
     */
    _chart.boxWidth = function (boxWidth) {
        if (!arguments.length) {
            return _boxWidth;
        }
        _boxWidth = d3.functor(boxWidth);
        return _chart;
    };

    var boxTransform = function (d, i) {
        var xOffset = _chart.x()(_chart.keyAccessor()(d, i));
        return &#x27;translate(&#x27; + xOffset + &#x27;, 0)&#x27;;
    };

    _chart._preprocessData = function () {
        if (_chart.elasticX()) {
            _chart.x().domain([]);
        }
    };

    _chart.plotData = function () {
        var _calculatedBoxWidth = _boxWidth(_chart.effectiveWidth(), _chart.xUnitCount());

        _box.whiskers(_whiskers)
            .width(_calculatedBoxWidth)
            .height(_chart.e ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* - {@link http://dc-js.github.io/dc.js/examples/box-plot-time.html Box plot time example}
* - {@link http://dc-js.github.io/dc.js/examples/box-plot.html Box plot example}
* @class boxPlot
* @memberof dc
* @mixes dc.coordinateGridMixin
* @example
* // create a box plot under #chart-container1 element using the default global chart group
* var boxPlot1 = dc.<span class="apidocCodeKeywordSpan">boxPlot</span>(&#x27;#chart-container1&#x27;);
* // create a box plot under #chart-container2 element using chart group A
* var boxPlot2 = dc.boxPlot(&#x27;#chart-container2&#x27;, &#x27;chartGroupA&#x27;);
* @param {String|node|d3.selection} parent - Any valid
* {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying
* a dom block element such as a div; or a dom element or d3 selection.
* @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
* Interaction with a chart will only trigger events and redraws within the chart&#x27;s group.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.bubbleChart" id="apidoc.element.dc.dc.bubbleChart">
        function <span class="apidocSignatureSpan">dc.dc.</span>bubbleChart
        <span class="apidocSignatureSpan">(parent, chartGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bubbleChart = function (parent, chartGroup) {
    var _chart = dc.bubbleMixin(dc.coordinateGridMixin({}));

    var _elasticRadius = false;
    var _sortBubbleSize = false;

    _chart.transitionDuration(750);

    _chart.transitionDelay(0);

    var bubbleLocator = function (d) {
        return &#x27;translate(&#x27; + (bubbleX(d)) + &#x27;,&#x27; + (bubbleY(d)) + &#x27;)&#x27;;
    };

<span class="apidocCodeCommentSpan">    /**
     * Turn on or off the elastic bubble radius feature, or return the value of the flag. If this
     * feature is turned on, then bubble radii will be automatically rescaled to fit the chart better.
     * @method elasticRadius
     * @memberof dc.bubbleChart
     * @instance
     * @param {Boolean} [elasticRadius=false]
     * @returns {Boolean|dc.bubbleChart}
     */
</span>    _chart.elasticRadius = function (elasticRadius) {
        if (!arguments.length) {
            return _elasticRadius;
        }
        _elasticRadius = elasticRadius;
        return _chart;
    };

    /**
     * Turn on or off the bubble sorting feature, or return the value of the flag. If enabled,
     * bubbles will be sorted by their radius, with smaller bubbles in front.
     * @method sortBubbleSize
     * @memberof dc.bubbleChart
     * @instance
     * @param {Boolean} [sortBubbleSize=false]
     * @returns {Boolean|dc.bubbleChart}
     */
    _chart.sortBubbleSize = function (sortBubbleSize) {
        if (!arguments.length) {
            return _sortBubbleSize;
        }
        _sortBubbleSize = sortBubbleSize;
        return _chart;
    };

    _chart.plotData = function () {
        if (_elasticRadius) {
            _chart.r().domain([_chart.rMin(), _chart.rMax()]);
        }

        _chart.r().range([_chart.MIN_RADIUS, _chart.xAxisLength() * _chart.maxBubbleRelativeSize()]);

        var data = _chart.data();
        if (_sortBubbleSize) {
            // sort descending so smaller bubbles are on top
            var radiusAccessor = _chart.radiusValueAccessor();
            data.sort(function (a, b) { return d3.descending(radiusAccessor(a), radiusAccessor(b)); });
        }
        var bubbleG = _chart.chartBodyG().selectAll(&#x27;g.&#x27; + _chart.BUBBLE_NODE_CLASS)
                .data(data, function (d) { return d.key; });
        if (_sortBubbleSize) {
            // Call order here to update dom order based on sort
            bubbleG.order();
        }

        renderNodes(bubbleG);

        updateNodes(bubbleG);

        removeNodes(bubbleG);

        _chart.fadeDeselectedArea();
    };

    function renderNodes (bubbleG) {
        var bubbleGEnter = bubbleG.enter().append(&#x27;g&#x27;);

        bubbleGEnter
            .attr(&#x27;class&#x27;, _chart.BUBBLE_NODE_CLASS)
            .attr(&#x27;transform&#x27;, bubbleLocator)
            .append(&#x27;circle&#x27;).attr(&#x27;class&#x27;, function (d, i) {
                return _chart.BUBBLE_CLASS + &#x27; _&#x27; + i;
            })
            .on(&#x27;click&#x27;, _chart.onClick)
            .attr(&#x27;fill&#x27;, _chart.getColor)
            .attr(&#x27;r&#x27;, 0);
        dc.transition(bubbleG, _chart.transitionDuration(), _chart.transitionDelay())
            .select(&#x27;circle.&#x27; + _chart.BUBBLE_CLASS)
            .attr(&#x27;r&#x27;, function (d) {
                return _chart.bubbleR(d);
            })
            .attr(&#x27;opacity&#x27;, function (d) {
                return (_chart.bubbleR(d) &#x3e; 0) ? 1 : 0;
            });

        _chart._doRenderLabel(bubbleGEnter);

        _chart._doRenderTitles(bubbleGEnter);
    }

    function updateNodes (bubbleG) {
        dc.transition(bubbleG, _chart.transitionDuration(), _chart.transitionDelay())
            .attr(&#x27;transform&#x27;, bubbleLocator)
            .select(&#x27;circle.&#x27; + _chart.BUBBLE_CLASS)
            .attr(&#x27;fill&#x27;, _chart.getColor)
            .attr(&#x27;r&#x27;, function (d) {
                return _chart.bubbleR(d);
            })
            .attr(&#x27;opacity&#x27;, function (d) {
                return (_chart.bubbleR(d) &#x3e; 0) ? 1 : 0;
            });

        _chart.doUpdateLabels(bubbleG);
        _chart.doUpdateTitles(bubbleG);
    }

    function removeNodes (bubbleG) {
        bubbleG.exit().remove();
    }

    function bubbleX (d) {
        var x = _chart.x()(_chart.keyAccessor()(d)); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* - {@link http://dc-js.github.com/dc.js/vc/index.html US Venture Capital Landscape 2011}
* @class bubbleChart
* @memberof dc
* @mixes dc.bubbleMixin
* @mixes dc.coordinateGridMixin
* @example
* // create a bubble chart under #chart-container1 element using the default global chart group
* var bubbleChart1 = dc.<span class="apidocCodeKeywordSpan">bubbleChart</span>(&#x27;#chart-container1&#x27;);
* // create a bubble chart under #chart-container2 element using chart group A
* var bubbleChart2 = dc.bubbleChart(&#x27;#chart-container2&#x27;, &#x27;chartGroupA&#x27;);
* @param {String|node|d3.selection} parent - Any valid
* {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying
* a dom block element such as a div; or a dom element or d3 selection.
* @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
* Interaction with a chart will only trigger events and redraws within the chart&#x27;s group.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.bubbleMixin" id="apidoc.element.dc.dc.bubbleMixin">
        function <span class="apidocSignatureSpan">dc.dc.</span>bubbleMixin
        <span class="apidocSignatureSpan">(_chart)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bubbleMixin = function (_chart) {
    var _maxBubbleRelativeSize = 0.3;
    var _minRadiusWithLabel = 10;

    _chart.BUBBLE_NODE_CLASS = &#x27;node&#x27;;
    _chart.BUBBLE_CLASS = &#x27;bubble&#x27;;
    _chart.MIN_RADIUS = 10;

    _chart = dc.colorMixin(_chart);

    _chart.renderLabel(true);

    _chart.data(function (group) {
        return group.top(Infinity);
    });

    var _r = d3.scale.linear().domain([0, 100]);

    var _rValueAccessor = function (d) {
        return d.r;
    };

<span class="apidocCodeCommentSpan">    /**
     * Get or set the bubble radius scale. By default the bubble chart uses
     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Quantitative-Scales.md#linear d3.scale.linear().domain([0,
100])}
     * as its radius scale.
     * @method r
     * @memberof dc.bubbleMixin
     * @instance
     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Scales.md d3.scale}
     * @param {d3.scale} [bubbleRadiusScale=d3.scale.linear().domain([0, 100])]
     * @returns {d3.scale|dc.bubbleMixin}
     */
</span>    _chart.r = function (bubbleRadiusScale) {
        if (!arguments.length) {
            return _r;
        }
        _r = bubbleRadiusScale;
        return _chart;
    };

    /**
     * Get or set the radius value accessor function. If set, the radius value accessor function will
     * be used to retrieve a data value for each bubble. The data retrieved then will be mapped using
     * the r scale to the actual bubble radius. This allows you to encode a data dimension using bubble
     * size.
     * @method radiusValueAccessor
     * @memberof dc.bubbleMixin
     * @instance
     * @param {Function} [radiusValueAccessor]
     * @returns {Function|dc.bubbleMixin}
     */
    _chart.radiusValueAccessor = function (radiusValueAccessor) {
        if (!arguments.length) {
            return _rValueAccessor;
        }
        _rValueAccessor = radiusValueAccessor;
        return _chart;
    };

    _chart.rMin = function () {
        var min = d3.min(_chart.data(), function (e) {
            return _chart.radiusValueAccessor()(e);
        });
        return min;
    };

    _chart.rMax = function () {
        var max = d3.max(_chart.data(), function (e) {
            return _chart.radiusValueAccessor()(e);
        });
        return max;
    };

    _chart.bubbleR = function (d) {
        var value = _chart.radiusValueAccessor()(d);
        var r = _chart.r()(value);
        if (isNaN(r) || value &#x3c;= 0) {
            r = 0;
        }
        return r;
    };

    var labelFunction = function (d) {
        return _chart.label()(d);
    };

    var shouldLabel = function (d) {
        return (_chart.bubbleR(d) &#x3e; _minRadiusWithLabel);
    };

    var labelOpacity = function (d) {
        return shouldLabel(d) ? 1 : 0;
    };

    var labelPointerEvent = function (d) {
        return shouldLabel(d) ? &#x27;all&#x27; : &#x27;none&#x27;;
    };

    _chart._doRenderLabel = function (bubbleGEnter) {
        if (_chart.renderLabel()) {
            var label = bubbleGEnter.select(&#x27;text&#x27;);

            if (label.empty()) {
                label = bubbleGEnter.append(&#x27;text&#x27;)
                    .attr(&#x27;text-anchor&#x27;, &#x27;middle&#x27;)
                    .attr(&#x27;dy&#x27;, &#x27;.3em&#x27;)
                    .on(&#x27;click&#x27;, _chart.onClick);
            }

            label
                .attr(&#x27;opacity&#x27;, 0)
                .attr(&#x27;pointer-events&#x27;, labelPointerEvent)
                .text(labelFunction);
            dc.transition(label, _chart.transitionDuration(), _chart.transitionDelay())
                .attr(&#x27;opacity&#x27;, labelOpacity);
        }
    };

    _chart.doUpdateLabels = function (bubbleGEnter) {
        if (_chart.renderLabel()) {
            var labels = bubbleGEnter.select(&#x27;text&#x27;)
                .attr(&#x27;pointer-events&#x27;, labelPointerEvent)
                .text(labelFunction);
            dc.transition(labels, _chart.transitionDuration(), _chart.transitionDelay())
                .attr(&#x27;opacity&#x27;, labelOpacity);
        }
    };

    var titleFunction = function (d) {
        return _chart.title()(d);
    };

    _chart._doRenderTitles = function (g) {
        if (_chart.renderTitle()) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart&#x27;s group.
 * @returns {dc.bubbleChart}
 */
dc.bubbleChart = function (parent, chartGroup) {
var _chart = dc.<span class="apidocCodeKeywordSpan">bubbleMixin</span>(dc.coordinateGridMixin({}));

var _elasticRadius = false;
var _sortBubbleSize = false;

_chart.transitionDuration(750);

_chart.transitionDelay(0);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.bubbleOverlay" id="apidoc.element.dc.dc.bubbleOverlay">
        function <span class="apidocSignatureSpan">dc.dc.</span>bubbleOverlay
        <span class="apidocSignatureSpan">(parent, chartGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bubbleOverlay = function (parent, chartGroup) {
    var BUBBLE_OVERLAY_CLASS = &#x27;bubble-overlay&#x27;;
    var BUBBLE_NODE_CLASS = &#x27;node&#x27;;
    var BUBBLE_CLASS = &#x27;bubble&#x27;;

<span class="apidocCodeCommentSpan">    /**
     * **mandatory**
     *
     * Set the underlying svg image element. Unlike other dc charts this chart will not generate a svg
     * element; therefore the bubble overlay chart will not work if this function is not invoked. If the
     * underlying image is a bitmap, then an empty svg will need to be created on top of the image.
     * @method svg
     * @memberof dc.bubbleOverlay
     * @instance
     * @example
     * // set up underlying svg element
     * chart.svg(d3.select(&#x27;#chart svg&#x27;));
     * @param {SVGElement|d3.selection} [imageElement]
     * @returns {dc.bubbleOverlay}
     */
</span>    var _chart = dc.bubbleMixin(dc.baseMixin({}));
    var _g;
    var _points = [];

    _chart.transitionDuration(750);

    _chart.transitionDelay(0);

    _chart.radiusValueAccessor(function (d) {
        return d.value;
    });

    /**
     * **mandatory**
     *
     * Set up a data point on the overlay. The name of a data point should match a specific &#x27;key&#x27; among
     * data groups generated using keyAccessor.  If a match is found (point name &#x3c;-&#x3e; data group key)
     * then a bubble will be generated at the position specified by the function. x and y
     * value specified here are relative to the underlying svg.
     * @method point
     * @memberof dc.bubbleOverlay
     * @instance
     * @param {String} name
     * @param {Number} x
     * @param {Number} y
     * @returns {dc.bubbleOverlay}
     */
    _chart.point = function (name, x, y) {
        _points.push({name: name, x: x, y: y});
        return _chart;
    };

    _chart._doRender = function () {
        _g = initOverlayG();

        _chart.r().range([_chart.MIN_RADIUS, _chart.width() * _chart.maxBubbleRelativeSize()]);

        initializeBubbles();

        _chart.fadeDeselectedArea();

        return _chart;
    };

    function initOverlayG () {
        _g = _chart.select(&#x27;g.&#x27; + BUBBLE_OVERLAY_CLASS);
        if (_g.empty()) {
            _g = _chart.svg().append(&#x27;g&#x27;).attr(&#x27;class&#x27;, BUBBLE_OVERLAY_CLASS);
        }
        return _g;
    }

    function initializeBubbles () {
        var data = mapData();

        _points.forEach(function (point) {
            var nodeG = getNodeG(point, data);

            var circle = nodeG.select(&#x27;circle.&#x27; + BUBBLE_CLASS);

            if (circle.empty()) {
                circle = nodeG.append(&#x27;circle&#x27;)
                    .attr(&#x27;class&#x27;, BUBBLE_CLASS)
                    .attr(&#x27;r&#x27;, 0)
                    .attr(&#x27;fill&#x27;, _chart.getColor)
                    .on(&#x27;click&#x27;, _chart.onClick);
            }

            dc.transition(circle, _chart.transitionDuration(), _chart.transitionDelay())
                .attr(&#x27;r&#x27;, function (d) {
                    return _chart.bubbleR(d);
                });

            _chart._doRenderLabel(nodeG);

            _chart._doRenderTitles(nodeG);
        });
    }

    function mapData () {
        var data = {};
        _chart.data().forEach(function (datum) {
            data[_chart.keyAccessor()(datum)] = datum;
        });
        return data;
    }

    function getNodeG (point, data) {
        var bubbleNodeClass = BUBBLE_NODE_CLASS + &#x27; &#x27; + dc.utils.nameToId(point.name);

        var nodeG = _g.select(&#x27;g.&#x27; + dc.utils.nameToId(point.name));

        if (nodeG.empty()) {
            nodeG = _g.append(&#x27;g&#x27;)
                .attr(&#x27;class&#x27;, bubbleNodeClass)
                .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + point.x + &#x27;,&#x27; + point.y + &#x27;)&#x27;);
        }

        nodeG.datum(data[point.name]);

        return nodeG;
    }

    _chart._doRedraw = function () {
        updateBubbles();

        _chart.fadeDeselectedArea();

        return _chart;
    };

    function updateBubbles () {
        var data = mapData();

        _points.forEach(function (point) {
            var nodeG = getNodeG(point, data);

            var circle = nodeG.select(&#x27;circle.&#x27; + BUBBLE_CLASS);

            dc.transition(circle, _chart.transitionDuration(), _chart.trans ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.capMixin" id="apidoc.element.dc.dc.capMixin">
        function <span class="apidocSignatureSpan">dc.dc.</span>capMixin
        <span class="apidocSignatureSpan">(_chart)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">capMixin = function (_chart) {

    var _cap = Infinity;

    var _othersLabel = &#x27;Others&#x27;;

    var _othersGrouper = function (topRows) {
        var topRowsSum = d3.sum(topRows, _chart.valueAccessor()),
            allRows = _chart.group().all(),
            allRowsSum = d3.sum(allRows, _chart.valueAccessor()),
            topKeys = topRows.map(_chart.keyAccessor()),
            allKeys = allRows.map(_chart.keyAccessor()),
            topSet = d3.set(topKeys),
            others = allKeys.filter(function (d) {return !topSet.has(d);});
        if (allRowsSum &#x3e; topRowsSum) {
            return topRows.concat([{
                &#x27;others&#x27;: others,
                &#x27;key&#x27;: _chart.othersLabel(),
                &#x27;value&#x27;: allRowsSum - topRowsSum
            }]);
        }
        return topRows;
    };

    _chart.cappedKeyAccessor = function (d, i) {
        if (d.others) {
            return d.key;
        }
        return _chart.keyAccessor()(d, i);
    };

    _chart.cappedValueAccessor = function (d, i) {
        if (d.others) {
            return d.value;
        }
        return _chart.valueAccessor()(d, i);
    };

    _chart.data(function (group) {
        if (_cap === Infinity) {
            return _chart._computeOrderedGroups(group.all());
        } else {
            var topRows = group.top(_cap); // ordered by crossfilter group order (default value)
            topRows = _chart._computeOrderedGroups(topRows); // re-order using ordering (default key)
            if (_othersGrouper) {
                return _othersGrouper(topRows);
            }
            return topRows;
        }
    });

<span class="apidocCodeCommentSpan">    /**
     * Get or set the count of elements to that will be included in the cap. If there is an
     * {@link dc.capMixin#othersGrouper othersGrouper}, any further elements will be combined in an
     * extra element with its name determined by {@link dc.capMixin#othersLabel othersLabel}.
     *
     * Up through dc.js 2.0.*, capping uses
     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group_top group.top(N)},
     * which selects the largest items according to
     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group_order group.order()}.
     * The chart then sorts the items according to {@link dc.baseMixin#ordering baseMixin.ordering()}.
     * So the two values essentially have to agree, but if the former is incorrect (it&#x27;s easy to
     * forget about `group.order()`), the latter will mask the problem. This also makes
     * {@link https://github.com/dc-js/dc.js/wiki/FAQ#fake-groups fake groups} difficult to
     * implement.
     *
     * In dc.js 2.1 and forward, only
     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group_all group.all()}
     * and `baseMixin.ordering()` are used.
     * @method cap
     * @memberof dc.capMixin
     * @instance
     * @param {Number} [count=Infinity]
     * @returns {Number|dc.capMixin}
     */
</span>    _chart.cap = function (count) {
        if (!arguments.length) {
            return _cap;
        }
        _cap = count;
        return _chart;
    };

    /**
     * Get or set the label for *Others* slice when slices cap is specified.
     * @method othersLabel
     * @memberof dc.capMixin
     * @instance
     * @param {String} [label=&#x22;Others&#x22;]
     * @returns {String|dc.capMixin}
     */
    _chart.othersLabel = function (label) {
        if (!arguments.length) {
            return _othersLabel;
        }
        _othersLabel = label;
        return _chart;
    };

    /**
     * Get or set the grouper function that will perform the insertion of data for the *Others* slice
     * if the slices cap is specified. If set to a falsy value, no others will be added. By default the
     * grouper function computes the sum of all values below the cap.
     * @method othersGrouper
     * @memberof dc.capMixin
     * @instance
     * @example
     * // Do not show others
     * chart.othersGrouper(null);
     * // Default others grouper
     * chart.othersGrouper(function (topRows) {
     *    var topRowsSum = d3.sum(topRows, _chart ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var _g;
var _cx;
var _cy;
var _minAngleForLabel = DEFAULT_MIN_ANGLE_FOR_LABEL;
var _externalLabelRadius;
var _drawPaths = false;
var _chart = dc.<span class="apidocCodeKeywordSpan">capMixin</span>(dc.colorMixin(dc.baseMixin({})));

_chart.colorAccessor(_chart.cappedKeyAccessor);

_chart.title(function (d) {
    return _chart.cappedKeyAccessor(d) + &#x27;: &#x27; + _chart.cappedValueAccessor(d);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.capped" id="apidoc.element.dc.dc.capped">
        function <span class="apidocSignatureSpan">dc.dc.</span>capped
        <span class="apidocSignatureSpan">(_chart)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">capped = function (_chart) {

    var _cap = Infinity;

    var _othersLabel = &#x27;Others&#x27;;

    var _othersGrouper = function (topRows) {
        var topRowsSum = d3.sum(topRows, _chart.valueAccessor()),
            allRows = _chart.group().all(),
            allRowsSum = d3.sum(allRows, _chart.valueAccessor()),
            topKeys = topRows.map(_chart.keyAccessor()),
            allKeys = allRows.map(_chart.keyAccessor()),
            topSet = d3.set(topKeys),
            others = allKeys.filter(function (d) {return !topSet.has(d);});
        if (allRowsSum &#x3e; topRowsSum) {
            return topRows.concat([{
                &#x27;others&#x27;: others,
                &#x27;key&#x27;: _chart.othersLabel(),
                &#x27;value&#x27;: allRowsSum - topRowsSum
            }]);
        }
        return topRows;
    };

    _chart.cappedKeyAccessor = function (d, i) {
        if (d.others) {
            return d.key;
        }
        return _chart.keyAccessor()(d, i);
    };

    _chart.cappedValueAccessor = function (d, i) {
        if (d.others) {
            return d.value;
        }
        return _chart.valueAccessor()(d, i);
    };

    _chart.data(function (group) {
        if (_cap === Infinity) {
            return _chart._computeOrderedGroups(group.all());
        } else {
            var topRows = group.top(_cap); // ordered by crossfilter group order (default value)
            topRows = _chart._computeOrderedGroups(topRows); // re-order using ordering (default key)
            if (_othersGrouper) {
                return _othersGrouper(topRows);
            }
            return topRows;
        }
    });

<span class="apidocCodeCommentSpan">    /**
     * Get or set the count of elements to that will be included in the cap. If there is an
     * {@link dc.capMixin#othersGrouper othersGrouper}, any further elements will be combined in an
     * extra element with its name determined by {@link dc.capMixin#othersLabel othersLabel}.
     *
     * Up through dc.js 2.0.*, capping uses
     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group_top group.top(N)},
     * which selects the largest items according to
     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group_order group.order()}.
     * The chart then sorts the items according to {@link dc.baseMixin#ordering baseMixin.ordering()}.
     * So the two values essentially have to agree, but if the former is incorrect (it&#x27;s easy to
     * forget about `group.order()`), the latter will mask the problem. This also makes
     * {@link https://github.com/dc-js/dc.js/wiki/FAQ#fake-groups fake groups} difficult to
     * implement.
     *
     * In dc.js 2.1 and forward, only
     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group_all group.all()}
     * and `baseMixin.ordering()` are used.
     * @method cap
     * @memberof dc.capMixin
     * @instance
     * @param {Number} [count=Infinity]
     * @returns {Number|dc.capMixin}
     */
</span>    _chart.cap = function (count) {
        if (!arguments.length) {
            return _cap;
        }
        _cap = count;
        return _chart;
    };

    /**
     * Get or set the label for *Others* slice when slices cap is specified.
     * @method othersLabel
     * @memberof dc.capMixin
     * @instance
     * @param {String} [label=&#x22;Others&#x22;]
     * @returns {String|dc.capMixin}
     */
    _chart.othersLabel = function (label) {
        if (!arguments.length) {
            return _othersLabel;
        }
        _othersLabel = label;
        return _chart;
    };

    /**
     * Get or set the grouper function that will perform the insertion of data for the *Others* slice
     * if the slices cap is specified. If set to a falsy value, no others will be added. By default the
     * grouper function computes the sum of all values below the cap.
     * @method othersGrouper
     * @memberof dc.capMixin
     * @instance
     * @example
     * // Do not show others
     * chart.othersGrouper(null);
     * // Default others grouper
     * chart.othersGrouper(function (topRows) {
     *    var topRowsSum = d3.sum(topRows, _chart ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.colorChart" id="apidoc.element.dc.dc.colorChart">
        function <span class="apidocSignatureSpan">dc.dc.</span>colorChart
        <span class="apidocSignatureSpan">(_chart)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">colorChart = function (_chart) {
    var _colors = d3.scale.category20c();
    var _defaultAccessor = true;

    var _colorAccessor = function (d) { return _chart.keyAccessor()(d); };

<span class="apidocCodeCommentSpan">    /**
     * Retrieve current color scale or set a new color scale. This methods accepts any function that
     * operates like a d3 scale.
     * @method colors
     * @memberof dc.colorMixin
     * @instance
     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Scales.md d3.scale}
     * @example
     * // alternate categorical scale
     * chart.colors(d3.scale.category20b());
     * // ordinal scale
     * chart.colors(d3.scale.ordinal().range([&#x27;red&#x27;,&#x27;green&#x27;,&#x27;blue&#x27;]));
     * // convenience method, the same as above
     * chart.ordinalColors([&#x27;red&#x27;,&#x27;green&#x27;,&#x27;blue&#x27;]);
     * // set a linear scale
     * chart.linearColors([&#x22;#4575b4&#x22;, &#x22;#ffffbf&#x22;, &#x22;#a50026&#x22;]);
     * @param {d3.scale} [colorScale=d3.scale.category20c()]
     * @returns {d3.scale|dc.colorMixin}
     */
</span>    _chart.colors = function (colorScale) {
        if (!arguments.length) {
            return _colors;
        }
        if (colorScale instanceof Array) {
            _colors = d3.scale.quantize().range(colorScale); // deprecated legacy support, note: this fails for ordinal domains
        } else {
            _colors = d3.functor(colorScale);
        }
        return _chart;
    };

    /**
     * Convenience method to set the color scale to
     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Ordinal-Scales.md#ordinal d3.scale.ordinal} with
     * range `r`.
     * @method ordinalColors
     * @memberof dc.colorMixin
     * @instance
     * @param {Array&#x3c;String&#x3e;} r
     * @returns {dc.colorMixin}
     */
    _chart.ordinalColors = function (r) {
        return _chart.colors(d3.scale.ordinal().range(r));
    };

    /**
     * Convenience method to set the color scale to an Hcl interpolated linear scale with range `r`.
     * @method linearColors
     * @memberof dc.colorMixin
     * @instance
     * @param {Array&#x3c;Number&#x3e;} r
     * @returns {dc.colorMixin}
     */
    _chart.linearColors = function (r) {
        return _chart.colors(d3.scale.linear()
                             .range(r)
                             .interpolate(d3.interpolateHcl));
    };

    /**
     * Set or the get color accessor function. This function will be used to map a data point in a
     * crossfilter group to a color value on the color scale. The default function uses the key
     * accessor.
     * @method colorAccessor
     * @memberof dc.colorMixin
     * @instance
     * @example
     * // default index based color accessor
     * .colorAccessor(function (d, i){return i;})
     * // color accessor for a multi-value crossfilter reduction
     * .colorAccessor(function (d){return d.value.absGain;})
     * @param {Function} [colorAccessor]
     * @returns {Function|dc.colorMixin}
     */
    _chart.colorAccessor = function (colorAccessor) {
        if (!arguments.length) {
            return _colorAccessor;
        }
        _colorAccessor = colorAccessor;
        _defaultAccessor = false;
        return _chart;
    };

    // what is this?
    _chart.defaultColorAccessor = function () {
        return _defaultAccessor;
    };

    /**
     * Set or get the current domain for the color mapping function. The domain must be supplied as an
     * array.
     *
     * Note: previously this method accepted a callback function. Instead you may use a custom scale
     * set by {@link dc.colorMixin#colors .colors}.
     * @method colorDomain
     * @memberof dc.colorMixin
     * @instance
     * @param {Array&#x3c;String&#x3e;} [domain]
     * @returns {Array&#x3c;String&#x3e;|dc.colorMixin}
     */
    _chart.colorDomain = function (domain) {
        if (!arguments.length) {
            return _colors.domain();
        }
        _colors.domain(domain);
        return _chart;
    };

    /**
     * Set the domain by determining the min and max values as retrieved by
     * {@link dc.colorMixin#colorAccessor .colorAccessor} over the chart&#x27;s dataset.
     * @method calculateColorDomain
     * @ ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.colorMixin" id="apidoc.element.dc.dc.colorMixin">
        function <span class="apidocSignatureSpan">dc.dc.</span>colorMixin
        <span class="apidocSignatureSpan">(_chart)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">colorMixin = function (_chart) {
    var _colors = d3.scale.category20c();
    var _defaultAccessor = true;

    var _colorAccessor = function (d) { return _chart.keyAccessor()(d); };

<span class="apidocCodeCommentSpan">    /**
     * Retrieve current color scale or set a new color scale. This methods accepts any function that
     * operates like a d3 scale.
     * @method colors
     * @memberof dc.colorMixin
     * @instance
     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Scales.md d3.scale}
     * @example
     * // alternate categorical scale
     * chart.colors(d3.scale.category20b());
     * // ordinal scale
     * chart.colors(d3.scale.ordinal().range([&#x27;red&#x27;,&#x27;green&#x27;,&#x27;blue&#x27;]));
     * // convenience method, the same as above
     * chart.ordinalColors([&#x27;red&#x27;,&#x27;green&#x27;,&#x27;blue&#x27;]);
     * // set a linear scale
     * chart.linearColors([&#x22;#4575b4&#x22;, &#x22;#ffffbf&#x22;, &#x22;#a50026&#x22;]);
     * @param {d3.scale} [colorScale=d3.scale.category20c()]
     * @returns {d3.scale|dc.colorMixin}
     */
</span>    _chart.colors = function (colorScale) {
        if (!arguments.length) {
            return _colors;
        }
        if (colorScale instanceof Array) {
            _colors = d3.scale.quantize().range(colorScale); // deprecated legacy support, note: this fails for ordinal domains
        } else {
            _colors = d3.functor(colorScale);
        }
        return _chart;
    };

    /**
     * Convenience method to set the color scale to
     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Ordinal-Scales.md#ordinal d3.scale.ordinal} with
     * range `r`.
     * @method ordinalColors
     * @memberof dc.colorMixin
     * @instance
     * @param {Array&#x3c;String&#x3e;} r
     * @returns {dc.colorMixin}
     */
    _chart.ordinalColors = function (r) {
        return _chart.colors(d3.scale.ordinal().range(r));
    };

    /**
     * Convenience method to set the color scale to an Hcl interpolated linear scale with range `r`.
     * @method linearColors
     * @memberof dc.colorMixin
     * @instance
     * @param {Array&#x3c;Number&#x3e;} r
     * @returns {dc.colorMixin}
     */
    _chart.linearColors = function (r) {
        return _chart.colors(d3.scale.linear()
                             .range(r)
                             .interpolate(d3.interpolateHcl));
    };

    /**
     * Set or the get color accessor function. This function will be used to map a data point in a
     * crossfilter group to a color value on the color scale. The default function uses the key
     * accessor.
     * @method colorAccessor
     * @memberof dc.colorMixin
     * @instance
     * @example
     * // default index based color accessor
     * .colorAccessor(function (d, i){return i;})
     * // color accessor for a multi-value crossfilter reduction
     * .colorAccessor(function (d){return d.value.absGain;})
     * @param {Function} [colorAccessor]
     * @returns {Function|dc.colorMixin}
     */
    _chart.colorAccessor = function (colorAccessor) {
        if (!arguments.length) {
            return _colorAccessor;
        }
        _colorAccessor = colorAccessor;
        _defaultAccessor = false;
        return _chart;
    };

    // what is this?
    _chart.defaultColorAccessor = function () {
        return _defaultAccessor;
    };

    /**
     * Set or get the current domain for the color mapping function. The domain must be supplied as an
     * array.
     *
     * Note: previously this method accepted a callback function. Instead you may use a custom scale
     * set by {@link dc.colorMixin#colors .colors}.
     * @method colorDomain
     * @memberof dc.colorMixin
     * @instance
     * @param {Array&#x3c;String&#x3e;} [domain]
     * @returns {Array&#x3c;String&#x3e;|dc.colorMixin}
     */
    _chart.colorDomain = function (domain) {
        if (!arguments.length) {
            return _colors.domain();
        }
        _colors.domain(domain);
        return _chart;
    };

    /**
     * Set the domain by determining the min and max values as retrieved by
     * {@link dc.colorMixin#colorAccessor .colorAccessor} over the chart&#x27;s dataset.
     * @method calculateColorDomain
     * @ ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var GRID_LINE_CLASS = &#x27;grid-line&#x27;;
var HORIZONTAL_CLASS = &#x27;horizontal&#x27;;
var VERTICAL_CLASS = &#x27;vertical&#x27;;
var Y_AXIS_LABEL_CLASS = &#x27;y-axis-label&#x27;;
var X_AXIS_LABEL_CLASS = &#x27;x-axis-label&#x27;;
var DEFAULT_AXIS_LABEL_PADDING = 12;

_chart = dc.<span class="apidocCodeKeywordSpan">colorMixin</span>(dc.marginMixin(dc.baseMixin(_chart)));

_chart.colors(d3.scale.category10());
_chart._mandatoryAttributes().push(&#x27;x&#x27;);
var _parent;
var _g;
var _chartBodyG;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.compositeChart" id="apidoc.element.dc.dc.compositeChart">
        function <span class="apidocSignatureSpan">dc.dc.</span>compositeChart
        <span class="apidocSignatureSpan">(parent, chartGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compositeChart = function (parent, chartGroup) {

    var SUB_CHART_CLASS = &#x27;sub&#x27;;
    var DEFAULT_RIGHT_Y_AXIS_LABEL_PADDING = 12;

    var _chart = dc.coordinateGridMixin({});
    var _children = [];

    var _childOptions = {};

    var _shareColors = false,
        _shareTitle = true,
        _alignYAxes = false;

    var _rightYAxis = d3.svg.axis(),
        _rightYAxisLabel = 0,
        _rightYAxisLabelPadding = DEFAULT_RIGHT_Y_AXIS_LABEL_PADDING,
        _rightY,
        _rightAxisGridLines = false;

    _chart._mandatoryAttributes([]);
    _chart.transitionDuration(500);
    _chart.transitionDelay(0);

    dc.override(_chart, &#x27;_generateG&#x27;, function () {
        var g = this.__generateG();

        for (var i = 0; i &#x3c; _children.length; ++i) {
            var child = _children[i];

            generateChildG(child, i);

            if (!child.dimension()) {
                child.dimension(_chart.dimension());
            }
            if (!child.group()) {
                child.group(_chart.group());
            }

            child.chartGroup(_chart.chartGroup());
            child.svg(_chart.svg());
            child.xUnits(_chart.xUnits());
            child.transitionDuration(_chart.transitionDuration(), _chart.transitionDelay());
            child.brushOn(_chart.brushOn());
            child.renderTitle(_chart.renderTitle());
            child.elasticX(_chart.elasticX());
        }

        return g;
    });

    _chart._brushing = function () {
        var extent = _chart.extendBrush();
        var brushIsEmpty = _chart.brushIsEmpty(extent);

        for (var i = 0; i &#x3c; _children.length; ++i) {
            _children[i].replaceFilter(brushIsEmpty ? null : extent);
        }
    };

    _chart._prepareYAxis = function () {
        var left = (leftYAxisChildren().length !== 0);
        var right = (rightYAxisChildren().length !== 0);
        var ranges = calculateYAxisRanges(left, right);

        if (left) { prepareLeftYAxis(ranges); }
        if (right) { prepareRightYAxis(ranges); }

        if (leftYAxisChildren().length &#x3e; 0 &#x26;&#x26; !_rightAxisGridLines) {
            _chart._renderHorizontalGridLinesForAxis(_chart.g(), _chart.y(), _chart.yAxis());
        } else if (rightYAxisChildren().length &#x3e; 0) {
            _chart._renderHorizontalGridLinesForAxis(_chart.g(), _rightY, _rightYAxis);
        }
    };

    _chart.renderYAxis = function () {
        if (leftYAxisChildren().length !== 0) {
            _chart.renderYAxisAt(&#x27;y&#x27;, _chart.yAxis(), _chart.margins().left);
            _chart.renderYAxisLabel(&#x27;y&#x27;, _chart.yAxisLabel(), -90);
        }

        if (rightYAxisChildren().length !== 0) {
            _chart.renderYAxisAt(&#x27;yr&#x27;, _chart.rightYAxis(), _chart.width() - _chart.margins().right);
            _chart.renderYAxisLabel(&#x27;yr&#x27;, _chart.rightYAxisLabel(), 90, _chart.width() - _rightYAxisLabelPadding);
        }
    };

    function calculateYAxisRanges (left, right) {
        var lyAxisMin, lyAxisMax, ryAxisMin, ryAxisMax;
        var ranges;

        if (left) {
            lyAxisMin = yAxisMin();
            lyAxisMax = yAxisMax();
        }

        if (right) {
            ryAxisMin = rightYAxisMin();
            ryAxisMax = rightYAxisMax();
        }

        if (_chart.alignYAxes() &#x26;&#x26; left &#x26;&#x26; right) {
            ranges = alignYAxisRanges(lyAxisMin, lyAxisMax, ryAxisMin, ryAxisMax);
        }

        return ranges || {
            lyAxisMin: lyAxisMin,
            lyAxisMax: lyAxisMax,
            ryAxisMin: ryAxisMin,
            ryAxisMax: ryAxisMax
        };
    }

    function alignYAxisRanges (lyAxisMin, lyAxisMax, ryAxisMin, ryAxisMax) {
        // since the two series will share a zero, each Y is just a multiple
        // of the other. and the ratio should be the ratio of the ranges of the
        // input data, so that they come out the same height. so we just min/max

        // note: both ranges already include zero due to the stack mixin (#667)
        // if #667 changes, we can reconsider whether we want data height or
        // height from zero to be equal. and it will be possible for the axes
        // ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Grid. You can overlay (compose) different bar/line/area charts in a single composite chart to
* achieve some quite flexible charting effects.
* @class compositeChart
* @memberof dc
* @mixes dc.coordinateGridMixin
* @example
* // create a composite chart under #chart-container1 element using the default global chart group
* var compositeChart1 = dc.<span class="apidocCodeKeywordSpan">compositeChart</span>(&#x27;#chart-container1&#x27;);
* // create a composite chart under #chart-container2 element using chart group A
* var compositeChart2 = dc.compositeChart(&#x27;#chart-container2&#x27;, &#x27;chartGroupA&#x27;);
* @param {String|node|d3.selection} parent - Any valid
* {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying
* a dom block element such as a div; or a dom element or d3 selection.
* @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
* Interaction with a chart will only trigger events and redraws within the chart&#x27;s group.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.coordinateGridChart" id="apidoc.element.dc.dc.coordinateGridChart">
        function <span class="apidocSignatureSpan">dc.dc.</span>coordinateGridChart
        <span class="apidocSignatureSpan">(_chart)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coordinateGridChart = function (_chart) {
    var GRID_LINE_CLASS = &#x27;grid-line&#x27;;
    var HORIZONTAL_CLASS = &#x27;horizontal&#x27;;
    var VERTICAL_CLASS = &#x27;vertical&#x27;;
    var Y_AXIS_LABEL_CLASS = &#x27;y-axis-label&#x27;;
    var X_AXIS_LABEL_CLASS = &#x27;x-axis-label&#x27;;
    var DEFAULT_AXIS_LABEL_PADDING = 12;

    _chart = dc.colorMixin(dc.marginMixin(dc.baseMixin(_chart)));

    _chart.colors(d3.scale.category10());
    _chart._mandatoryAttributes().push(&#x27;x&#x27;);
    var _parent;
    var _g;
    var _chartBodyG;

    var _x;
    var _xOriginalDomain;
    var _xAxis = d3.svg.axis().orient(&#x27;bottom&#x27;);
    var _xUnits = dc.units.integers;
    var _xAxisPadding = 0;
    var _xAxisPaddingUnit = &#x27;day&#x27;;
    var _xElasticity = false;
    var _xAxisLabel;
    var _xAxisLabelPadding = 0;
    var _lastXDomain;

    var _y;
    var _yAxis = d3.svg.axis().orient(&#x27;left&#x27;);
    var _yAxisPadding = 0;
    var _yElasticity = false;
    var _yAxisLabel;
    var _yAxisLabelPadding = 0;

    var _brush = d3.svg.brush();
    var _brushOn = true;
    var _round;

    var _renderHorizontalGridLine = false;
    var _renderVerticalGridLine = false;

    var _refocused = false, _resizing = false;
    var _unitCount;

    var _zoomScale = [1, Infinity];
    var _zoomOutRestrict = true;

    var _zoom = d3.behavior.zoom().on(&#x27;zoom&#x27;, zoomHandler);
    var _nullZoom = d3.behavior.zoom().on(&#x27;zoom&#x27;, null);
    var _hasBeenMouseZoomable = false;

    var _rangeChart;
    var _focusChart;

    var _mouseZoomable = false;
    var _clipPadding = 0;

    var _outerRangeBandPadding = 0.5;
    var _rangeBandPadding = 0;

    var _useRightYAxis = false;

<span class="apidocCodeCommentSpan">    /**
     * When changing the domain of the x or y scale, it is necessary to tell the chart to recalculate
     * and redraw the axes. (`.rescale()` is called automatically when the x or y scale is replaced
     * with {@link dc.coordinateGridMixin+x .x()} or {@link dc.coordinateGridMixin#y .y()}, and has
     * no effect on elastic scales.)
     * @method rescale
     * @memberof dc.coordinateGridMixin
     * @instance
     * @returns {dc.coordinateGridMixin}
     */
</span>    _chart.rescale = function () {
        _unitCount = undefined;
        _resizing = true;
        return _chart;
    };

    _chart.resizing = function () {
        return _resizing;
    };

    /**
     * Get or set the range selection chart associated with this instance. Setting the range selection
     * chart using this function will automatically update its selection brush when the current chart
     * zooms in. In return the given range chart will also automatically attach this chart as its focus
     * chart hence zoom in when range brush updates.
     *
     * Usually the range and focus charts will share a dimension. The range chart will set the zoom
     * boundaries for the focus chart, so its dimension values must be compatible with the domain of
     * the focus chart.
     *
     * See the [Nasdaq 100 Index](http://dc-js.github.com/dc.js/) example for this effect in action.
     * @method rangeChart
     * @memberof dc.coordinateGridMixin
     * @instance
     * @param {dc.coordinateGridMixin} [rangeChart]
     * @returns {dc.coordinateGridMixin}
     */
    _chart.rangeChart = function (rangeChart) {
        if (!arguments.length) {
            return _rangeChart;
        }
        _rangeChart = rangeChart;
        _rangeChart.focusChart(_chart);
        return _chart;
    };

    /**
     * Get or set the scale extent for mouse zooms.
     * @method zoomScale
     * @memberof dc.coordinateGridMixin
     * @instance
     * @param {Array&#x3c;Number|Date&#x3e;} [extent=[1, Infinity]]
     * @returns {Array&#x3c;Number|Date&#x3e;|dc.coordinateGridMixin}
     */
    _chart.zoomScale = function (extent) {
        if (!arguments.length) {
            return _zoomScale;
        }
        _zoomScale = extent;
        return _chart;
    };

    /**
     * Get or set the zoom restriction for the chart. If true limits the zoom to origional domain of the chart.
     * @method zoomOutRestrict
     * @memberof dc.coordinateGridMixin
     * @instance
     * @param {Boolean} [zoomOutRestrict=true]
     * @ ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.coordinateGridMixin" id="apidoc.element.dc.dc.coordinateGridMixin">
        function <span class="apidocSignatureSpan">dc.dc.</span>coordinateGridMixin
        <span class="apidocSignatureSpan">(_chart)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coordinateGridMixin = function (_chart) {
    var GRID_LINE_CLASS = &#x27;grid-line&#x27;;
    var HORIZONTAL_CLASS = &#x27;horizontal&#x27;;
    var VERTICAL_CLASS = &#x27;vertical&#x27;;
    var Y_AXIS_LABEL_CLASS = &#x27;y-axis-label&#x27;;
    var X_AXIS_LABEL_CLASS = &#x27;x-axis-label&#x27;;
    var DEFAULT_AXIS_LABEL_PADDING = 12;

    _chart = dc.colorMixin(dc.marginMixin(dc.baseMixin(_chart)));

    _chart.colors(d3.scale.category10());
    _chart._mandatoryAttributes().push(&#x27;x&#x27;);
    var _parent;
    var _g;
    var _chartBodyG;

    var _x;
    var _xOriginalDomain;
    var _xAxis = d3.svg.axis().orient(&#x27;bottom&#x27;);
    var _xUnits = dc.units.integers;
    var _xAxisPadding = 0;
    var _xAxisPaddingUnit = &#x27;day&#x27;;
    var _xElasticity = false;
    var _xAxisLabel;
    var _xAxisLabelPadding = 0;
    var _lastXDomain;

    var _y;
    var _yAxis = d3.svg.axis().orient(&#x27;left&#x27;);
    var _yAxisPadding = 0;
    var _yElasticity = false;
    var _yAxisLabel;
    var _yAxisLabelPadding = 0;

    var _brush = d3.svg.brush();
    var _brushOn = true;
    var _round;

    var _renderHorizontalGridLine = false;
    var _renderVerticalGridLine = false;

    var _refocused = false, _resizing = false;
    var _unitCount;

    var _zoomScale = [1, Infinity];
    var _zoomOutRestrict = true;

    var _zoom = d3.behavior.zoom().on(&#x27;zoom&#x27;, zoomHandler);
    var _nullZoom = d3.behavior.zoom().on(&#x27;zoom&#x27;, null);
    var _hasBeenMouseZoomable = false;

    var _rangeChart;
    var _focusChart;

    var _mouseZoomable = false;
    var _clipPadding = 0;

    var _outerRangeBandPadding = 0.5;
    var _rangeBandPadding = 0;

    var _useRightYAxis = false;

<span class="apidocCodeCommentSpan">    /**
     * When changing the domain of the x or y scale, it is necessary to tell the chart to recalculate
     * and redraw the axes. (`.rescale()` is called automatically when the x or y scale is replaced
     * with {@link dc.coordinateGridMixin+x .x()} or {@link dc.coordinateGridMixin#y .y()}, and has
     * no effect on elastic scales.)
     * @method rescale
     * @memberof dc.coordinateGridMixin
     * @instance
     * @returns {dc.coordinateGridMixin}
     */
</span>    _chart.rescale = function () {
        _unitCount = undefined;
        _resizing = true;
        return _chart;
    };

    _chart.resizing = function () {
        return _resizing;
    };

    /**
     * Get or set the range selection chart associated with this instance. Setting the range selection
     * chart using this function will automatically update its selection brush when the current chart
     * zooms in. In return the given range chart will also automatically attach this chart as its focus
     * chart hence zoom in when range brush updates.
     *
     * Usually the range and focus charts will share a dimension. The range chart will set the zoom
     * boundaries for the focus chart, so its dimension values must be compatible with the domain of
     * the focus chart.
     *
     * See the [Nasdaq 100 Index](http://dc-js.github.com/dc.js/) example for this effect in action.
     * @method rangeChart
     * @memberof dc.coordinateGridMixin
     * @instance
     * @param {dc.coordinateGridMixin} [rangeChart]
     * @returns {dc.coordinateGridMixin}
     */
    _chart.rangeChart = function (rangeChart) {
        if (!arguments.length) {
            return _rangeChart;
        }
        _rangeChart = rangeChart;
        _rangeChart.focusChart(_chart);
        return _chart;
    };

    /**
     * Get or set the scale extent for mouse zooms.
     * @method zoomScale
     * @memberof dc.coordinateGridMixin
     * @instance
     * @param {Array&#x3c;Number|Date&#x3e;} [extent=[1, Infinity]]
     * @returns {Array&#x3c;Number|Date&#x3e;|dc.coordinateGridMixin}
     */
    _chart.zoomScale = function (extent) {
        if (!arguments.length) {
            return _zoomScale;
        }
        _zoomScale = extent;
        return _chart;
    };

    /**
     * Get or set the zoom restriction for the chart. If true limits the zoom to origional domain of the chart.
     * @method zoomOutRestrict
     * @memberof dc.coordinateGridMixin
     * @instance
     * @param {Boolean} [zoomOutRestrict=true]
     * @ ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {dc.barChart}
 */
dc.barChart = function (parent, chartGroup) {
var MIN_BAR_WIDTH = 1;
var DEFAULT_GAP_BETWEEN_BARS = 2;
var LABEL_PADDING = 3;

var _chart = dc.stackMixin(dc.<span class="apidocCodeKeywordSpan">coordinateGridMixin</span>({}));

var _gap = DEFAULT_GAP_BETWEEN_BARS;
var _centerBar = false;
var _alwaysUseRounding = false;

var _barWidth;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.crossfilter" id="apidoc.element.dc.dc.crossfilter">
        function <span class="apidocSignatureSpan">dc.dc.</span>crossfilter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function crossfilter() {
  var crossfilter = {
    add: add,
    remove: removeData,
    dimension: dimension,
    groupAll: groupAll,
    size: size
  };

  var data = [], // the records
      n = 0, // the number of records; data.length
      m = 0, // a bit mask representing which dimensions are in use
      M = 8, // number of dimensions that can fit in `filters`
      filters = crossfilter_array8(0), // M bits per record; 1 is filtered out
      filterListeners = [], // when the filters change
      dataListeners = [], // when data is added
      removeDataListeners = []; // when data is removed

  // Adds the specified new records to this crossfilter.
  function add(newData) {
    var n0 = n,
        n1 = newData.length;

    // If there&#x27;s actually new data to add…
    // Merge the new data into the existing data.
    // Lengthen the filter bitset to handle the new records.
    // Notify listeners (dimensions and groups) that new data is available.
    if (n1) {
      data = data.concat(newData);
      filters = crossfilter_arrayLengthen(filters, n += n1);
      dataListeners.forEach(function(l) { l(newData, n0, n1); });
    }

    return crossfilter;
  }

  // Removes all records that match the current filters.
  function removeData() {
    var newIndex = crossfilter_index(n, n),
        removed = [];
    for (var i = 0, j = 0; i &#x3c; n; ++i) {
      if (filters[i]) newIndex[i] = j++;
      else removed.push(i);
    }

    // Remove all matching records from groups.
    filterListeners.forEach(function(l) { l(0, [], removed); });

    // Update indexes.
    removeDataListeners.forEach(function(l) { l(newIndex); });

    // Remove old filters and data by overwriting.
    for (var i = 0, j = 0, k; i &#x3c; n; ++i) {
      if (k = filters[i]) {
        if (i !== j) filters[j] = k, data[j] = data[i];
        ++j;
      }
    }
    data.length = j;
    while (n &#x3e; j) filters[--n] = 0;
  }

  // Adds a new dimension with the specified value accessor function.
  function dimension(value) {
    var dimension = {
      filter: filter,
      filterExact: filterExact,
      filterRange: filterRange,
      filterFunction: filterFunction,
      filterAll: filterAll,
      top: top,
      bottom: bottom,
      group: group,
      groupAll: groupAll,
      dispose: dispose,
      remove: dispose // for backwards-compatibility
    };

    var one = ~m &#x26; -~m, // lowest unset bit as mask, e.g., 00001000
        zero = ~one, // inverted one, e.g., 11110111
        values, // sorted, cached array
        index, // value rank ↦ object id
        newValues, // temporary array storing newly-added values
        newIndex, // temporary array storing newly-added index
        sort = quicksort_by(function(i) { return newValues[i]; }),
        refilter = crossfilter_filterAll, // for recomputing filter
        refilterFunction, // the custom filter function in use
        indexListeners = [], // when data is added
        dimensionGroups = [],
        lo0 = 0,
        hi0 = 0;

    // Updating a dimension is a two-stage process. First, we must update the
    // associated filters for the newly-added records. Once all dimensions have
    // updated their filters, the groups are notified to update.
    dataListeners.unshift(preAdd);
    dataListeners.push(postAdd);

    removeDataListeners.push(removeData);

    // Incorporate any existing data into this dimension, and make sure that the
    // filter bitset is wide enough to handle the new dimension.
    m |= one;
    if (M &#x3e;= 32 ? !one : m &#x26; -(1 &#x3c;&#x3c; M)) {
      filters = crossfilter_arrayWiden(filters, M &#x3c;&#x3c;= 1);
    }
    preAdd(data, 0, n);
    postAdd(data, 0, n);

    // Incorporates the specified new records into this dimension.
    // This function is responsible for updating filters, values, and index.
    function preAdd(newData, n0, n1) {

      // Permute new values into natural order using a sorted index.
      newValues = newData.map(value);
      newIndex = sort(crossfilter_range(n1), 0, n1);
      newValues = permute(newValues, newIndex);

      // Bisect newValues to determine which new ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.dataCount" id="apidoc.element.dc.dc.dataCount">
        function <span class="apidocSignatureSpan">dc.dc.</span>dataCount
        <span class="apidocSignatureSpan">(parent, chartGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dataCount = function (parent, chartGroup) {
    var _formatNumber = d3.format(&#x27;,d&#x27;);
    var _chart = dc.baseMixin({});
    var _html = {some: &#x27;&#x27;, all: &#x27;&#x27;};

<span class="apidocCodeCommentSpan">    /**
     * Gets or sets an optional object specifying HTML templates to use depending how many items are
     * selected. The text `%total-count` will replaced with the total number of records, and the text
     * `%filter-count` will be replaced with the number of selected records.
     * - all: HTML template to use if all items are selected
     * - some: HTML template to use if not all items are selected
     * @method html
     * @memberof dc.dataCount
     * @instance
     * @example
     * counter.html({
     *      some: &#x27;%filter-count out of %total-count records selected&#x27;,
     *      all: &#x27;All records selected. Click on charts to apply filters&#x27;
     * })
     * @param {{some:String, all: String}} [options]
     * @returns {{some:String, all: String}|dc.dataCount}
     */
</span>    _chart.html = function (options) {
        if (!arguments.length) {
            return _html;
        }
        if (options.all) {
            _html.all = options.all;
        }
        if (options.some) {
            _html.some = options.some;
        }
        return _chart;
    };

    /**
     * Gets or sets an optional function to format the filter count and total count.
     * @method formatNumber
     * @memberof dc.dataCount
     * @instance
     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Formatting.md d3.format}
     * @example
     * counter.formatNumber(d3.format(&#x27;.2g&#x27;))
     * @param {Function} [formatter=d3.format(&#x27;.2g&#x27;)]
     * @returns {Function|dc.dataCount}
     */
    _chart.formatNumber = function (formatter) {
        if (!arguments.length) {
            return _formatNumber;
        }
        _formatNumber = formatter;
        return _chart;
    };

    _chart._doRender = function () {
        var tot = _chart.dimension().size(),
            val = _chart.group().value();
        var all = _formatNumber(tot);
        var selected = _formatNumber(val);

        if ((tot === val) &#x26;&#x26; (_html.all !== &#x27;&#x27;)) {
            _chart.root().html(_html.all.replace(&#x27;%total-count&#x27;, all).replace(&#x27;%filter-count&#x27;, selected));
        } else if (_html.some !== &#x27;&#x27;) {
            _chart.root().html(_html.some.replace(&#x27;%total-count&#x27;, all).replace(&#x27;%filter-count&#x27;, selected));
        } else {
            _chart.selectAll(&#x27;.total-count&#x27;).text(all);
            _chart.selectAll(&#x27;.filter-count&#x27;).text(selected);
        }
        return _chart;
    };

    _chart._doRedraw = function () {
        return _chart._doRender();
    };

    return _chart.anchor(parent, chartGroup);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @class dataCount
* @memberof dc
* @mixes dc.baseMixin
* @example
* var ndx = crossfilter(data);
* var all = ndx.groupAll();
*
* dc.<span class="apidocCodeKeywordSpan">dataCount</span>(&#x27;.dc-data-count&#x27;)
*     .dimension(ndx)
*     .group(all);
* @param {String|node|d3.selection} parent - Any valid
* {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying
* a dom block element such as a div; or a dom element or d3 selection.
* @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
* Interaction with a chart will only trigger events and redraws within the chart&#x27;s group.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.dataGrid" id="apidoc.element.dc.dc.dataGrid">
        function <span class="apidocSignatureSpan">dc.dc.</span>dataGrid
        <span class="apidocSignatureSpan">(parent, chartGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dataGrid = function (parent, chartGroup) {
    var LABEL_CSS_CLASS = &#x27;dc-grid-label&#x27;;
    var ITEM_CSS_CLASS = &#x27;dc-grid-item&#x27;;
    var GROUP_CSS_CLASS = &#x27;dc-grid-group&#x27;;
    var GRID_CSS_CLASS = &#x27;dc-grid-top&#x27;;

    var _chart = dc.baseMixin({});

    var _size = 999; // shouldn&#x27;t be needed, but you might
    var _html = function (d) { return &#x27;you need to provide an html() handling param:  &#x27; + JSON.stringify(d); };
    var _sortBy = function (d) {
        return d;
    };
    var _order = d3.ascending;
    var _beginSlice = 0, _endSlice;

    var _htmlGroup = function (d) {
        return &#x27;&#x3c;div class=\&#x27;&#x27; + GROUP_CSS_CLASS + &#x27;\&#x27;&#x3e;&#x3c;h1 class=\&#x27;&#x27; + LABEL_CSS_CLASS + &#x27;\&#x27;&#x3e;&#x27; +
            _chart.keyAccessor()(d) + &#x27;&#x3c;/h1&#x3e;&#x3c;/div&#x3e;&#x27;;
    };

    _chart._doRender = function () {
        _chart.selectAll(&#x27;div.&#x27; + GRID_CSS_CLASS).remove();

        renderItems(renderGroups());

        return _chart;
    };

    function renderGroups () {
        var groups = _chart.root().selectAll(&#x27;div.&#x27; + GRID_CSS_CLASS)
                .data(nestEntries(), function (d) {
                    return _chart.keyAccessor()(d);
                });

        var itemGroup = groups
                .enter()
                .append(&#x27;div&#x27;)
                .attr(&#x27;class&#x27;, GRID_CSS_CLASS);

        if (_htmlGroup) {
            itemGroup
                .html(function (d) {
                    return _htmlGroup(d);
                });
        }

        groups.exit().remove();
        return itemGroup;
    }

    function nestEntries () {
        var entries = _chart.dimension().top(_size);

        return d3.nest()
            .key(_chart.group())
            .sortKeys(_order)
            .entries(entries.sort(function (a, b) {
                return _order(_sortBy(a), _sortBy(b));
            }).slice(_beginSlice, _endSlice));
    }

    function renderItems (groups) {
        var items = groups.order()
                .selectAll(&#x27;div.&#x27; + ITEM_CSS_CLASS)
                .data(function (d) {
                    return d.values;
                });

        items.enter()
            .append(&#x27;div&#x27;)
            .attr(&#x27;class&#x27;, ITEM_CSS_CLASS)
            .html(function (d) {
                return _html(d);
            });

        items.exit().remove();

        return items;
    }

    _chart._doRedraw = function () {
        return _chart._doRender();
    };

<span class="apidocCodeCommentSpan">    /**
     * Get or set the group function for the data grid. The group function takes a data row and
     * returns the key to specify to {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_nest d3.nest}
     * to split rows into groups.
     *
     * Do not pass in a crossfilter group as this will not work.
     * @method group
     * @memberof dc.dataGrid
     * @instance
     * @example
     * // group rows by the value of their field
     * chart
     *     .group(function(d) { return d.field; })
     * @param {Function} groupFunction Function taking a row of data and returning the nest key.
     * @returns {Function|dc.dataTable}
     */
</span>
    /**
     * Get or set the index of the beginning slice which determines which entries get displayed by the widget.
     * Useful when implementing pagination.
     * @method beginSlice
     * @memberof dc.dataGrid
     * @instance
     * @param {Number} [beginSlice=0]
     * @returns {Number|dc.dataGrid}
     */
    _chart.beginSlice = function (beginSlice) {
        if (!arguments.length) {
            return _beginSlice;
        }
        _beginSlice = beginSlice;
        return _chart;
    };

    /**
     * Get or set the index of the end slice which determines which entries get displayed by the widget.
     * Useful when implementing pagination.
     * @method endSlice
     * @memberof dc.dataGrid
     * @instance
     * @param {Number} [endSlice]
     * @returns {Number|dc.dataGrid}
     */
    _chart.endSlice = function (endSlice) {
        if (!arguments.length) {
            return _endSlice;
        }
        _endSlice = endSlice;
        return _chart;
    };

    /**
     * Get or set the grid size which determines the number of items displ ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.dataTable" id="apidoc.element.dc.dc.dataTable">
        function <span class="apidocSignatureSpan">dc.dc.</span>dataTable
        <span class="apidocSignatureSpan">(parent, chartGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dataTable = function (parent, chartGroup) {
    var LABEL_CSS_CLASS = &#x27;dc-table-label&#x27;;
    var ROW_CSS_CLASS = &#x27;dc-table-row&#x27;;
    var COLUMN_CSS_CLASS = &#x27;dc-table-column&#x27;;
    var GROUP_CSS_CLASS = &#x27;dc-table-group&#x27;;
    var HEAD_CSS_CLASS = &#x27;dc-table-head&#x27;;

    var _chart = dc.baseMixin({});

    var _size = 25;
    var _columns = [];
    var _sortBy = function (d) {
        return d;
    };
    var _order = d3.ascending;
    var _beginSlice = 0;
    var _endSlice;
    var _showGroups = true;

    _chart._doRender = function () {
        _chart.selectAll(&#x27;tbody&#x27;).remove();

        renderRows(renderGroups());

        return _chart;
    };

    _chart._doColumnValueFormat = function (v, d) {
        return ((typeof v === &#x27;function&#x27;) ?
                v(d) :                          // v as function
                ((typeof v === &#x27;string&#x27;) ?
                 d[v] :                         // v is field name string
                 v.format(d)                        // v is Object, use fn (element 2)
                )
               );
    };

    _chart._doColumnHeaderFormat = function (d) {
        // if &#x27;function&#x27;, convert to string representation
        // show a string capitalized
        // if an object then display its label string as-is.
        return (typeof d === &#x27;function&#x27;) ?
                _chart._doColumnHeaderFnToString(d) :
                ((typeof d === &#x27;string&#x27;) ?
                 _chart._doColumnHeaderCapitalize(d) : String(d.label));
    };

    _chart._doColumnHeaderCapitalize = function (s) {
        // capitalize
        return s.charAt(0).toUpperCase() + s.slice(1);
    };

    _chart._doColumnHeaderFnToString = function (f) {
        // columnString(f) {
        var s = String(f);
        var i1 = s.indexOf(&#x27;return &#x27;);
        if (i1 &#x3e;= 0) {
            var i2 = s.lastIndexOf(&#x27;;&#x27;);
            if (i2 &#x3e;= 0) {
                s = s.substring(i1 + 7, i2);
                var i3 = s.indexOf(&#x27;numberFormat&#x27;);
                if (i3 &#x3e;= 0) {
                    s = s.replace(&#x27;numberFormat&#x27;, &#x27;&#x27;);
                }
            }
        }
        return s;
    };

    function renderGroups () {
        // The &#x27;original&#x27; example uses all &#x27;functions&#x27;.
        // If all &#x27;functions&#x27; are used, then don&#x27;t remove/add a header, and leave
        // the html alone. This preserves the functionality of earlier releases.
        // A 2nd option is a string representing a field in the data.
        // A third option is to supply an Object such as an array of &#x27;information&#x27;, and
        // supply your own _doColumnHeaderFormat and _doColumnValueFormat functions to
        // create what you need.
        var bAllFunctions = true;
        _columns.forEach(function (f) {
            bAllFunctions = bAllFunctions &#x26; (typeof f === &#x27;function&#x27;);
        });

        if (!bAllFunctions) {
            // ensure one thead
            var thead = _chart.selectAll(&#x27;thead&#x27;).data([0]);
            thead.enter().append(&#x27;thead&#x27;);
            thead.exit().remove();

            // with one tr
            var headrow = thead.selectAll(&#x27;tr&#x27;).data([0]);
            headrow.enter().append(&#x27;tr&#x27;);
            headrow.exit().remove();

            // with a th for each column
            var headcols = headrow.selectAll(&#x27;th&#x27;)
                .data(_columns);
            headcols.enter().append(&#x27;th&#x27;);
            headcols.exit().remove();

            headcols
                .attr(&#x27;class&#x27;, HEAD_CSS_CLASS)
                    .html(function (d) {
                        return (_chart._doColumnHeaderFormat(d));

                    });
        }

        var groups = _chart.root().selectAll(&#x27;tbody&#x27;)
            .data(nestEntries(), function (d) {
                return _chart.keyAccessor()(d);
            });

        var rowGroup = groups
            .enter()
            .append(&#x27;tbody&#x27;);

        if (_showGroups === true) {
            rowGroup
                .append(&#x27;tr&#x27;)
                .attr(&#x27;class&#x27;, GROUP_CSS_CLASS)
                    .append(&#x27;td&#x27;)
                    .attr(&#x27;class&#x27;, LABEL_CSS_CLASS)
                    .attr(&#x27;colspan&#x27;, _columns.l ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}


dc.dataCount(&#x22;.dc-data-count&#x22;)
  .dimension(ndx)
  .group(all);

dc.<span class="apidocCodeKeywordSpan">dataTable</span>(&#x22;.dc-data-table&#x22;)
      .dimension(country)
      .group(function (d) {
          return d.country;
      })
      .size(1000)
      .columns([
          function (d) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.dateFormat" id="apidoc.element.dc.dc.dateFormat">
        function <span class="apidocSignatureSpan">dc.dc.</span>dateFormat
        <span class="apidocSignatureSpan">{{signature}}</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">%m/%d/%Y</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {any} filter
 * @returns {String}
 */
dc.utils.printSingleValue = function (filter) {
var s = &#x27;&#x27; + filter;

if (filter instanceof Date) {
    s = dc.<span class="apidocCodeKeywordSpan">dateFormat</span>(filter);
} else if (typeof(filter) === &#x27;string&#x27;) {
    s = filter;
} else if (dc.utils.isFloat(filter)) {
    s = dc.utils.printSingleValue.fformat(filter);
} else if (dc.utils.isInteger(filter)) {
    s = Math.round(filter);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.deregisterAllCharts" id="apidoc.element.dc.dc.deregisterAllCharts">
        function <span class="apidocSignatureSpan">dc.dc.</span>deregisterAllCharts
        <span class="apidocSignatureSpan">(group)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deregisterAllCharts = function (group) {
    dc.chartRegistry.clear(group);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.deregisterChart" id="apidoc.element.dc.dc.deregisterChart">
        function <span class="apidocSignatureSpan">dc.dc.</span>deregisterChart
        <span class="apidocSignatureSpan">(chart, group)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deregisterChart = function (chart, group) {
    dc.chartRegistry.deregister(chart, group);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {String|dc.baseMixin}
 */
_chart.chartGroup = function (chartGroup) {
    if (!arguments.length) {
        return _chartGroup;
    }
    if (!_isChild) {
        dc.<span class="apidocCodeKeywordSpan">deregisterChart</span>(_chart, _chartGroup);
    }
    _chartGroup = chartGroup;
    if (!_isChild) {
        dc.registerChart(_chart, _chartGroup);
    }
    return _chart;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.filterAll" id="apidoc.element.dc.dc.filterAll">
        function <span class="apidocSignatureSpan">dc.dc.</span>filterAll
        <span class="apidocSignatureSpan">(group)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterAll = function (group) {
    var charts = dc.chartRegistry.list(group);
    for (var i = 0; i &#x3c; charts.length; ++i) {
        charts[i].filterAll();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @memberof dc
* @method filterAll
* @param {String} [group]
*/
dc.filterAll = function (group) {
   var charts = dc.chartRegistry.list(group);
   for (var i = 0; i &#x3c; charts.length; ++i) {
       charts[i].<span class="apidocCodeKeywordSpan">filterAll</span>();
   }
};

/**
* Reset zoom level / focus on all charts that belong to the given chart group. If the chart group is
* not given then only charts that belong to the default chart group will be reset.
* @memberof dc
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.geoChoroplethChart" id="apidoc.element.dc.dc.geoChoroplethChart">
        function <span class="apidocSignatureSpan">dc.dc.</span>geoChoroplethChart
        <span class="apidocSignatureSpan">(parent, chartGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">geoChoroplethChart = function (parent, chartGroup) {
    var _chart = dc.colorMixin(dc.baseMixin({}));

    _chart.colorAccessor(function (d) {
        return d || 0;
    });

    var _geoPath = d3.geo.path();
    var _projectionFlag;

    var _geoJsons = [];

    _chart._doRender = function () {
        _chart.resetSvg();
        for (var layerIndex = 0; layerIndex &#x3c; _geoJsons.length; ++layerIndex) {
            var states = _chart.svg().append(&#x27;g&#x27;)
                .attr(&#x27;class&#x27;, &#x27;layer&#x27; + layerIndex);

            var regionG = states.selectAll(&#x27;g.&#x27; + geoJson(layerIndex).name)
                .data(geoJson(layerIndex).data)
                .enter()
                .append(&#x27;g&#x27;)
                .attr(&#x27;class&#x27;, geoJson(layerIndex).name);

            regionG
                .append(&#x27;path&#x27;)
                .attr(&#x27;fill&#x27;, &#x27;white&#x27;)
                .attr(&#x27;d&#x27;, _geoPath);

            regionG.append(&#x27;title&#x27;);

            plotData(layerIndex);
        }
        _projectionFlag = false;
    };

    function plotData (layerIndex) {
        var data = generateLayeredData();

        if (isDataLayer(layerIndex)) {
            var regionG = renderRegionG(layerIndex);

            renderPaths(regionG, layerIndex, data);

            renderTitle(regionG, layerIndex, data);
        }
    }

    function generateLayeredData () {
        var data = {};
        var groupAll = _chart.data();
        for (var i = 0; i &#x3c; groupAll.length; ++i) {
            data[_chart.keyAccessor()(groupAll[i])] = _chart.valueAccessor()(groupAll[i]);
        }
        return data;
    }

    function isDataLayer (layerIndex) {
        return geoJson(layerIndex).keyAccessor;
    }

    function renderRegionG (layerIndex) {
        var regionG = _chart.svg()
            .selectAll(layerSelector(layerIndex))
            .classed(&#x27;selected&#x27;, function (d) {
                return isSelected(layerIndex, d);
            })
            .classed(&#x27;deselected&#x27;, function (d) {
                return isDeselected(layerIndex, d);
            })
            .attr(&#x27;class&#x27;, function (d) {
                var layerNameClass = geoJson(layerIndex).name;
                var regionClass = dc.utils.nameToId(geoJson(layerIndex).keyAccessor(d));
                var baseClasses = layerNameClass + &#x27; &#x27; + regionClass;
                if (isSelected(layerIndex, d)) {
                    baseClasses += &#x27; selected&#x27;;
                }
                if (isDeselected(layerIndex, d)) {
                    baseClasses += &#x27; deselected&#x27;;
                }
                return baseClasses;
            });
        return regionG;
    }

    function layerSelector (layerIndex) {
        return &#x27;g.layer&#x27; + layerIndex + &#x27; g.&#x27; + geoJson(layerIndex).name;
    }

    function isSelected (layerIndex, d) {
        return _chart.hasFilter() &#x26;&#x26; _chart.hasFilter(getKey(layerIndex, d));
    }

    function isDeselected (layerIndex, d) {
        return _chart.hasFilter() &#x26;&#x26; !_chart.hasFilter(getKey(layerIndex, d));
    }

    function getKey (layerIndex, d) {
        return geoJson(layerIndex).keyAccessor(d);
    }

    function geoJson (index) {
        return _geoJsons[index];
    }

    function renderPaths (regionG, layerIndex, data) {
        var paths = regionG
            .select(&#x27;path&#x27;)
            .attr(&#x27;fill&#x27;, function () {
                var currentFill = d3.select(this).attr(&#x27;fill&#x27;);
                if (currentFill) {
                    return currentFill;
                }
                return &#x27;none&#x27;;
            })
            .on(&#x27;click&#x27;, function (d) {
                return _chart.onClick(d, layerIndex);
            });

        dc.transition(paths, _chart.transitionDuration(), _chart.transitionDelay()).attr(&#x27;fill&#x27;, function (d, i) {
            return _chart.getColor(data[geoJson(layerIndex).keyAccessor(d)], i);
        });
    }

    _chart.onClick = function (d, layerIndex) {
        var selectedRegion = geoJson(layerIndex).keyAccessor(d);
        dc.events.trigger(function () {
            _chart.filter(selectedRegion);
            _chart.redrawGroup();
        });
    };

    function renderTitle (region ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* - {@link http://dc-js.github.com/dc.js/vc/index.html US Venture Capital Landscape 2011}
* @class geoChoroplethChart
* @memberof dc
* @mixes dc.colorMixin
* @mixes dc.baseMixin
* @example
* // create a choropleth chart under &#x27;#us-chart&#x27; element using the default global chart group
* var chart1 = dc.<span class="apidocCodeKeywordSpan">geoChoroplethChart</span>(&#x27;#us-chart&#x27;);
* // create a choropleth chart under &#x27;#us-chart2&#x27; element using chart group A
* var chart2 = dc.compositeChart(&#x27;#us-chart2&#x27;, &#x27;chartGroupA&#x27;);
* @param {String|node|d3.selection} parent - Any valid
* {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying
* a dom block element such as a div; or a dom element or d3 selection.
* @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
* Interaction with a chart will only trigger events and redraws within the chart&#x27;s group.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.hasChart" id="apidoc.element.dc.dc.hasChart">
        function <span class="apidocSignatureSpan">dc.dc.</span>hasChart
        <span class="apidocSignatureSpan">(chart)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasChart = function (chart) {
    return dc.chartRegistry.has(chart);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.heatMap" id="apidoc.element.dc.dc.heatMap">
        function <span class="apidocSignatureSpan">dc.dc.</span>heatMap
        <span class="apidocSignatureSpan">(parent, chartGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heatMap = function (parent, chartGroup) {

    var DEFAULT_BORDER_RADIUS = 6.75;

    var _chartBody;

    var _cols;
    var _rows;
    var _xBorderRadius = DEFAULT_BORDER_RADIUS;
    var _yBorderRadius = DEFAULT_BORDER_RADIUS;

    var _chart = dc.colorMixin(dc.marginMixin(dc.baseMixin({})));
    _chart._mandatoryAttributes([&#x27;group&#x27;]);
    _chart.title(_chart.colorAccessor());

    var _colsLabel = function (d) {
        return d;
    };
    var _rowsLabel = function (d) {
        return d;
    };

<span class="apidocCodeCommentSpan">    /**
     * Set or get the column label function. The chart class uses this function to render
     * column labels on the X axis. It is passed the column name.
     * @method colsLabel
     * @memberof dc.heatMap
     * @instance
     * @example
     * // the default label function just returns the name
     * chart.colsLabel(function(d) { return d; });
     * @param  {Function} [labelFunction=function(d) { return d; }]
     * @returns {Function|dc.heatMap}
     */
</span>    _chart.colsLabel = function (labelFunction) {
        if (!arguments.length) {
            return _colsLabel;
        }
        _colsLabel = labelFunction;
        return _chart;
    };

    /**
     * Set or get the row label function. The chart class uses this function to render
     * row labels on the Y axis. It is passed the row name.
     * @method rowsLabel
     * @memberof dc.heatMap
     * @instance
     * @example
     * // the default label function just returns the name
     * chart.rowsLabel(function(d) { return d; });
     * @param  {Function} [labelFunction=function(d) { return d; }]
     * @returns {Function|dc.heatMap}
     */
    _chart.rowsLabel = function (labelFunction) {
        if (!arguments.length) {
            return _rowsLabel;
        }
        _rowsLabel = labelFunction;
        return _chart;
    };

    var _xAxisOnClick = function (d) { filterAxis(0, d); };
    var _yAxisOnClick = function (d) { filterAxis(1, d); };
    var _boxOnClick = function (d) {
        var filter = d.key;
        dc.events.trigger(function () {
            _chart.filter(filter);
            _chart.redrawGroup();
        });
    };

    function filterAxis (axis, value) {
        var cellsOnAxis = _chart.selectAll(&#x27;.box-group&#x27;).filter(function (d) {
            return d.key[axis] === value;
        });
        var unfilteredCellsOnAxis = cellsOnAxis.filter(function (d) {
            return !_chart.hasFilter(d.key);
        });
        dc.events.trigger(function () {
            var selection = unfilteredCellsOnAxis.empty() ? cellsOnAxis : unfilteredCellsOnAxis;
            var filters = selection.data().map(function (kv) {
                return dc.filters.TwoDimensionalFilter(kv.key);
            });
            _chart._filter([filters]);
            _chart.redrawGroup();
        });
    }

    dc.override(_chart, &#x27;filter&#x27;, function (filter) {
        if (!arguments.length) {
            return _chart._filter();
        }

        return _chart._filter(dc.filters.TwoDimensionalFilter(filter));
    });

    function uniq (d, i, a) {
        return !i || a[i - 1] !== d;
    }

    /**
     * Gets or sets the values used to create the rows of the heatmap, as an array. By default, all
     * the values will be fetched from the data using the value accessor, and they will be sorted in
     * ascending order.
     * @method rows
     * @memberof dc.heatMap
     * @instance
     * @param  {Array&#x3c;String|Number&#x3e;} [rows]
     * @returns {Array&#x3c;String|Number&#x3e;|dc.heatMap}
     */
    _chart.rows = function (rows) {
        if (arguments.length) {
            _rows = rows;
            return _chart;
        }
        if (_rows) {
            return _rows;
        }
        var rowValues = _chart.data().map(_chart.valueAccessor());
        rowValues.sort(d3.ascending);
        return d3.scale.ordinal().domain(rowValues.filter(uniq));
    };

    /**
     * Gets or sets the keys used to create the columns of the heatmap, as an array. By default, all
     * the values will be fetched from the data using the key accessor, and they will be sorted in
     * ascending order. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @class heatMap
* @memberof dc
* @mixes dc.colorMixin
* @mixes dc.marginMixin
* @mixes dc.baseMixin
* @example
* // create a heat map under #chart-container1 element using the default global chart group
* var heatMap1 = dc.<span class="apidocCodeKeywordSpan">heatMap</span>(&#x27;#chart-container1&#x27;);
* // create a heat map under #chart-container2 element using chart group A
* var heatMap2 = dc.heatMap(&#x27;#chart-container2&#x27;, &#x27;chartGroupA&#x27;);
* @param {String|node|d3.selection} parent - Any valid
* {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying
* a dom block element such as a div; or a dom element or d3 selection.
* @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
* Interaction with a chart will only trigger events and redraws within the chart&#x27;s group.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.instanceOfChart" id="apidoc.element.dc.dc.instanceOfChart">
        function <span class="apidocSignatureSpan">dc.dc.</span>instanceOfChart
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instanceOfChart = function (o) {
    return o instanceof Object &#x26;&#x26; o.__dcFlag__ &#x26;&#x26; true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {String} [chartGroup]
 * @returns {String|node|d3.selection|dc.baseMixin}
 */
_chart.anchor = function (parent, chartGroup) {
    if (!arguments.length) {
        return _anchor;
    }
    if (dc.<span class="apidocCodeKeywordSpan">instanceOfChart</span>(parent)) {
        _anchor = parent.anchor();
        _root = parent.root();
        _isChild = true;
    } else if (parent) {
        if (parent.select &#x26;&#x26; parent.classed) { // detect d3 selection
            _anchor = parent.node();
        } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.legend" id="apidoc.element.dc.dc.legend">
        function <span class="apidocSignatureSpan">dc.dc.</span>legend
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">legend = function () {
    var LABEL_GAP = 2;

    var _legend = {},
        _parent,
        _x = 0,
        _y = 0,
        _itemHeight = 12,
        _gap = 5,
        _horizontal = false,
        _legendWidth = 560,
        _itemWidth = 70,
        _autoItemWidth = false,
        _legendText = dc.pluck(&#x27;name&#x27;),
        _maxItems;

    var _g;

    _legend.parent = function (p) {
        if (!arguments.length) {
            return _parent;
        }
        _parent = p;
        return _legend;
    };

    _legend.render = function () {
        _parent.svg().select(&#x27;g.dc-legend&#x27;).remove();
        _g = _parent.svg().append(&#x27;g&#x27;)
            .attr(&#x27;class&#x27;, &#x27;dc-legend&#x27;)
            .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + _x + &#x27;,&#x27; + _y + &#x27;)&#x27;);
        var legendables = _parent.legendables();

        if (_maxItems !== undefined) {
            legendables = legendables.slice(0, _maxItems);
        }

        var itemEnter = _g.selectAll(&#x27;g.dc-legend-item&#x27;)
            .data(legendables)
            .enter()
            .append(&#x27;g&#x27;)
            .attr(&#x27;class&#x27;, &#x27;dc-legend-item&#x27;)
            .on(&#x27;mouseover&#x27;, function (d) {
                _parent.legendHighlight(d);
            })
            .on(&#x27;mouseout&#x27;, function (d) {
                _parent.legendReset(d);
            })
            .on(&#x27;click&#x27;, function (d) {
                d.chart.legendToggle(d);
            });

        _g.selectAll(&#x27;g.dc-legend-item&#x27;)
            .classed(&#x27;fadeout&#x27;, function (d) {
                return d.chart.isLegendableHidden(d);
            });

        if (legendables.some(dc.pluck(&#x27;dashstyle&#x27;))) {
            itemEnter
                .append(&#x27;line&#x27;)
                .attr(&#x27;x1&#x27;, 0)
                .attr(&#x27;y1&#x27;, _itemHeight / 2)
                .attr(&#x27;x2&#x27;, _itemHeight)
                .attr(&#x27;y2&#x27;, _itemHeight / 2)
                .attr(&#x27;stroke-width&#x27;, 2)
                .attr(&#x27;stroke-dasharray&#x27;, dc.pluck(&#x27;dashstyle&#x27;))
                .attr(&#x27;stroke&#x27;, dc.pluck(&#x27;color&#x27;));
        } else {
            itemEnter
                .append(&#x27;rect&#x27;)
                .attr(&#x27;width&#x27;, _itemHeight)
                .attr(&#x27;height&#x27;, _itemHeight)
                .attr(&#x27;fill&#x27;, function (d) {return d ? d.color : &#x27;blue&#x27;;});
        }

        itemEnter.append(&#x27;text&#x27;)
                .text(_legendText)
                .attr(&#x27;x&#x27;, _itemHeight + LABEL_GAP)
                .attr(&#x27;y&#x27;, function () {
                    return _itemHeight / 2 + (this.clientHeight ? this.clientHeight : 13) / 2 - 2;
                });

        var _cumulativeLegendTextWidth = 0;
        var row = 0;
        itemEnter.attr(&#x27;transform&#x27;, function (d, i) {
            if (_horizontal) {
                var itemWidth   = _autoItemWidth === true ? this.getBBox().width + _gap : _itemWidth;
                if ((_cumulativeLegendTextWidth + itemWidth) &#x3e; _legendWidth &#x26;&#x26; _cumulativeLegendTextWidth &#x3e; 0) {
                    ++row;
                    _cumulativeLegendTextWidth = 0;
                }
                var translateBy = &#x27;translate(&#x27; + _cumulativeLegendTextWidth + &#x27;,&#x27; + row * legendItemHeight() + &#x27;)&#x27;;
                _cumulativeLegendTextWidth += itemWidth;
                return translateBy;
            } else {
                return &#x27;translate(0,&#x27; + i * legendItemHeight() + &#x27;)&#x27;;
            }
        });
    };

    function legendItemHeight () {
        return _gap + _itemHeight;
    }

<span class="apidocCodeCommentSpan">    /**
     * Set or get x coordinate for legend widget.
     * @method x
     * @memberof dc.legend
     * @instance
     * @param  {Number} [x=0]
     * @returns {Number|dc.legend}
     */
</span>    _legend.x = function (x) {
        if (!arguments.length) {
            return _x;
        }
        _x = x;
        return _legend;
    };

    /**
     * Set or get y coordinate for legend widget.
     * @method y
     * @memberof dc.legend
     * @instance
     * @param  {Number} [y=0]
     * @returns {Number|dc.legend}
     */
    _legend.y = function (y) {
        if (!arguments.length) {
            return _y;
        }
        _y = y;
        return _legend;
    };

    /**
     * Set or get gap between legend items.
     * @ ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Attach a dc.legend widget to this chart. The legend widget will automatically draw legend labels
 * based on the color setting and names associated with each group.
 * @method legend
 * @memberof dc.baseMixin
 * @instance
 * @example
 * chart.<span class="apidocCodeKeywordSpan">legend</span>(dc.legend().x(400).y(10).itemHeight(13).gap(5))
 * @param {dc.legend} [legend]
 * @returns {dc.legend|dc.baseMixin}
 */
_chart.legend = function (legend) {
    if (!arguments.length) {
        return _legend;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.lineChart" id="apidoc.element.dc.dc.lineChart">
        function <span class="apidocSignatureSpan">dc.dc.</span>lineChart
        <span class="apidocSignatureSpan">(parent, chartGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lineChart = function (parent, chartGroup) {
    var DEFAULT_DOT_RADIUS = 5;
    var TOOLTIP_G_CLASS = &#x27;dc-tooltip&#x27;;
    var DOT_CIRCLE_CLASS = &#x27;dot&#x27;;
    var Y_AXIS_REF_LINE_CLASS = &#x27;yRef&#x27;;
    var X_AXIS_REF_LINE_CLASS = &#x27;xRef&#x27;;
    var DEFAULT_DOT_OPACITY = 1e-6;
    var LABEL_PADDING = 3;

    var _chart = dc.stackMixin(dc.coordinateGridMixin({}));
    var _renderArea = false;
    var _dotRadius = DEFAULT_DOT_RADIUS;
    var _dataPointRadius = null;
    var _dataPointFillOpacity = DEFAULT_DOT_OPACITY;
    var _dataPointStrokeOpacity = DEFAULT_DOT_OPACITY;
    var _interpolate = &#x27;linear&#x27;;
    var _tension = 0.7;
    var _defined;
    var _dashStyle;
    var _xyTipsOn = true;

    _chart.transitionDuration(500);
    _chart.transitionDelay(0);
    _chart._rangeBandPadding(1);

    _chart.plotData = function () {
        var chartBody = _chart.chartBodyG();
        var layersList = chartBody.select(&#x27;g.stack-list&#x27;);

        if (layersList.empty()) {
            layersList = chartBody.append(&#x27;g&#x27;).attr(&#x27;class&#x27;, &#x27;stack-list&#x27;);
        }

        var layers = layersList.selectAll(&#x27;g.stack&#x27;).data(_chart.data());

        var layersEnter = layers
            .enter()
            .append(&#x27;g&#x27;)
            .attr(&#x27;class&#x27;, function (d, i) {
                return &#x27;stack &#x27; + &#x27;_&#x27; + i;
            });

        drawLine(layersEnter, layers);

        drawArea(layersEnter, layers);

        drawDots(chartBody, layers);

        if (_chart.renderLabel()) {
            drawLabels(layers);
        }
    };

<span class="apidocCodeCommentSpan">    /**
     * Gets or sets the interpolator to use for lines drawn, by string name, allowing e.g. step
     * functions, splines, and cubic interpolation.  This is passed to
     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_interpolate d3.svg.line.interpolate} and
     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#area_interpolate d3.svg.area.interpolate},
     * where you can find a complete list of valid arguments.
     * @method interpolate
     * @memberof dc.lineChart
     * @instance
     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_interpolate d3.svg.line.interpolate
}
     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#area_interpolate d3.svg.area.interpolate
}
     * @param  {String} [interpolate=&#x27;linear&#x27;]
     * @returns {String|dc.lineChart}
     */
</span>    _chart.interpolate = function (interpolate) {
        if (!arguments.length) {
            return _interpolate;
        }
        _interpolate = interpolate;
        return _chart;
    };

    /**
     * Gets or sets the tension to use for lines drawn, in the range 0 to 1.
     * This parameter further customizes the interpolation behavior.  It is passed to
     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_tension d3.svg.line.tension} and
     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#area_tension d3.svg.area.tension}.
     * @method tension
     * @memberof dc.lineChart
     * @instance
     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_interpolate d3.svg.line.interpolate
}
     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#area_interpolate d3.svg.area.interpolate
}
     * @param  {Number} [tension=0.7]
     * @returns {Number|dc.lineChart}
     */
    _chart.tension = function (tension) {
        if (!arguments.length) {
            return _tension;
        }
        _tension = tension;
        return _chart;
    };

    /**
     * Gets or sets a function that will determine discontinuities in the line which should be
     * skipped: the path will be broken into separate subpaths if some points are undefined.
     * This function is passed to
     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_defined d3.svg.line.defined}
     *
     * Note: crossfilter will sometimes coerce nulls to 0, so you may need to carefully write
     * custom reduce functions to ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* - {@link http://dc-js.github.com/dc.js/crime/index.html Canadian City Crime Stats}
* @class lineChart
* @memberof dc
* @mixes dc.stackMixin
* @mixes dc.coordinateGridMixin
* @example
* // create a line chart under #chart-container1 element using the default global chart group
* var chart1 = dc.<span class="apidocCodeKeywordSpan">lineChart</span>(&#x27;#chart-container1&#x27;);
* // create a line chart under #chart-container2 element using chart group A
* var chart2 = dc.lineChart(&#x27;#chart-container2&#x27;, &#x27;chartGroupA&#x27;);
* // create a sub-chart under a composite parent chart
* var chart3 = dc.lineChart(compositeChart);
* @param {String|node|d3.selection|dc.compositeChart} parent - Any valid
* {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector}
* specifying a dom block element such as a div; or a dom element or d3 selection.  If the line
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.marginMixin" id="apidoc.element.dc.dc.marginMixin">
        function <span class="apidocSignatureSpan">dc.dc.</span>marginMixin
        <span class="apidocSignatureSpan">(_chart)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">marginMixin = function (_chart) {
    var _margin = {top: 10, right: 50, bottom: 30, left: 30};

<span class="apidocCodeCommentSpan">    /**
     * Get or set the margins for a particular coordinate grid chart instance. The margins is stored as
     * an associative Javascript array.
     * @method margins
     * @memberof dc.marginMixin
     * @instance
     * @example
     * var leftMargin = chart.margins().left; // 30 by default
     * chart.margins().left = 50;
     * leftMargin = chart.margins().left; // now 50
     * @param {{top: Number, right: Number, left: Number, bottom: Number}} [margins={top: 10, right: 50, bottom: 30, left: 30}]
     * @returns {{top: Number, right: Number, left: Number, bottom: Number}|dc.marginMixin}
     */
</span>    _chart.margins = function (margins) {
        if (!arguments.length) {
            return _margin;
        }
        _margin = margins;
        return _chart;
    };

    _chart.effectiveWidth = function () {
        return _chart.width() - _chart.margins().left - _chart.margins().right;
    };

    _chart.effectiveHeight = function () {
        return _chart.height() - _chart.margins().top - _chart.margins().bottom;
    };

    return _chart;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var GRID_LINE_CLASS = &#x27;grid-line&#x27;;
var HORIZONTAL_CLASS = &#x27;horizontal&#x27;;
var VERTICAL_CLASS = &#x27;vertical&#x27;;
var Y_AXIS_LABEL_CLASS = &#x27;y-axis-label&#x27;;
var X_AXIS_LABEL_CLASS = &#x27;x-axis-label&#x27;;
var DEFAULT_AXIS_LABEL_PADDING = 12;

_chart = dc.colorMixin(dc.<span class="apidocCodeKeywordSpan">marginMixin</span>(dc.baseMixin(_chart)));

_chart.colors(d3.scale.category10());
_chart._mandatoryAttributes().push(&#x27;x&#x27;);
var _parent;
var _g;
var _chartBodyG;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.marginable" id="apidoc.element.dc.dc.marginable">
        function <span class="apidocSignatureSpan">dc.dc.</span>marginable
        <span class="apidocSignatureSpan">(_chart)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">marginable = function (_chart) {
    var _margin = {top: 10, right: 50, bottom: 30, left: 30};

<span class="apidocCodeCommentSpan">    /**
     * Get or set the margins for a particular coordinate grid chart instance. The margins is stored as
     * an associative Javascript array.
     * @method margins
     * @memberof dc.marginMixin
     * @instance
     * @example
     * var leftMargin = chart.margins().left; // 30 by default
     * chart.margins().left = 50;
     * leftMargin = chart.margins().left; // now 50
     * @param {{top: Number, right: Number, left: Number, bottom: Number}} [margins={top: 10, right: 50, bottom: 30, left: 30}]
     * @returns {{top: Number, right: Number, left: Number, bottom: Number}|dc.marginMixin}
     */
</span>    _chart.margins = function (margins) {
        if (!arguments.length) {
            return _margin;
        }
        _margin = margins;
        return _chart;
    };

    _chart.effectiveWidth = function () {
        return _chart.width() - _chart.margins().left - _chart.margins().right;
    };

    _chart.effectiveHeight = function () {
        return _chart.height() - _chart.margins().top - _chart.margins().bottom;
    };

    return _chart;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.numberDisplay" id="apidoc.element.dc.dc.numberDisplay">
        function <span class="apidocSignatureSpan">dc.dc.</span>numberDisplay
        <span class="apidocSignatureSpan">(parent, chartGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numberDisplay = function (parent, chartGroup) {
    var SPAN_CLASS = &#x27;number-display&#x27;;
    var _formatNumber = d3.format(&#x27;.2s&#x27;);
    var _chart = dc.baseMixin({});
    var _html = {one: &#x27;&#x27;, some: &#x27;&#x27;, none: &#x27;&#x27;};
    var _lastValue;

    // dimension not required
    _chart._mandatoryAttributes([&#x27;group&#x27;]);

<span class="apidocCodeCommentSpan">    /**
     * Gets or sets an optional object specifying HTML templates to use depending on the number
     * displayed.  The text `%number` will be replaced with the current value.
     * - one: HTML template to use if the number is 1
     * - zero: HTML template to use if the number is 0
     * - some: HTML template to use otherwise
     * @method html
     * @memberof dc.numberDisplay
     * @instance
     * @example
     * numberWidget.html({
     *      one:&#x27;%number record&#x27;,
     *      some:&#x27;%number records&#x27;,
     *      none:&#x27;no records&#x27;})
     * @param {{one:String, some:String, none:String}} [html={one: &#x27;&#x27;, some: &#x27;&#x27;, none: &#x27;&#x27;}]
     * @returns {{one:String, some:String, none:String}|dc.numberDisplay}
     */
</span>    _chart.html = function (html) {
        if (!arguments.length) {
            return _html;
        }
        if (html.none) {
            _html.none = html.none;//if none available
        } else if (html.one) {
            _html.none = html.one;//if none not available use one
        } else if (html.some) {
            _html.none = html.some;//if none and one not available use some
        }
        if (html.one) {
            _html.one = html.one;//if one available
        } else if (html.some) {
            _html.one = html.some;//if one not available use some
        }
        if (html.some) {
            _html.some = html.some;//if some available
        } else if (html.one) {
            _html.some = html.one;//if some not available use one
        }
        return _chart;
    };

    /**
     * Calculate and return the underlying value of the display.
     * @method value
     * @memberof dc.numberDisplay
     * @instance
     * @returns {Number}
     */
    _chart.value = function () {
        return _chart.data();
    };

    _chart.data(function (group) {
        var valObj = group.value ? group.value() : group.top(1)[0];
        return _chart.valueAccessor()(valObj);
    });

    _chart.transitionDuration(250); // good default
    _chart.transitionDelay(0);

    _chart._doRender = function () {
        var newValue = _chart.value(),
            span = _chart.selectAll(&#x27;.&#x27; + SPAN_CLASS);

        if (span.empty()) {
            span = span.data([0])
                .enter()
                .append(&#x27;span&#x27;)
                .attr(&#x27;class&#x27;, SPAN_CLASS);
        }

        span.transition()
            .duration(_chart.transitionDuration())
            .delay(_chart.transitionDelay())
            .ease(&#x27;quad-out-in&#x27;)
            .tween(&#x27;text&#x27;, function () {
                // [XA] don&#x27;t try and interpolate from Infinity, else this breaks.
                var interpStart = isFinite(_lastValue) ? _lastValue : 0;
                var interp = d3.interpolateNumber(interpStart || 0, newValue);
                _lastValue = newValue;
                return function (t) {
                    var html = null, num = _chart.formatNumber()(interp(t));
                    if (newValue === 0 &#x26;&#x26; (_html.none !== &#x27;&#x27;)) {
                        html = _html.none;
                    } else if (newValue === 1 &#x26;&#x26; (_html.one !== &#x27;&#x27;)) {
                        html = _html.one;
                    } else if (_html.some !== &#x27;&#x27;) {
                        html = _html.some;
                    }
                    this.innerHTML = html ? html.replace(&#x27;%number&#x27;, num) : num;
                };
            });
    };

    _chart._doRedraw = function () {
        return _chart._doRender();
    };

    /**
     * Get or set a function to format the value for the display.
     * @method formatNumber
     * @memberof dc.numberDisplay
     * @instance
     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Formatting.md d3.format}
     * @param {Function} [formatter=d3.format(&#x27;.2s&#x27;)]
     * @returns {Function|dc.numberDisplay} ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Unlike other charts, you do not need to set a dimension. Instead a group object must be provided and
* a valueAccessor that returns a single value.
* @class numberDisplay
* @memberof dc
* @mixes dc.baseMixin
* @example
* // create a number display under #chart-container1 element using the default global chart group
* var display1 = dc.<span class="apidocCodeKeywordSpan">numberDisplay</span>(&#x27;#chart-container1&#x27;);
* @param {String|node|d3.selection} parent - Any valid
* {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying
* a dom block element such as a div; or a dom element or d3 selection.
* @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
* Interaction with a chart will only trigger events and redraws within the chart&#x27;s group.
* @returns {dc.numberDisplay}
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.optionalTransition" id="apidoc.element.dc.dc.optionalTransition">
        function <span class="apidocSignatureSpan">dc.dc.</span>optionalTransition
        <span class="apidocSignatureSpan">(enable, duration, delay, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">optionalTransition = function (enable, duration, delay, name) {
    if (enable) {
        return function (selection) {
            return dc.transition(selection, duration, delay, name);
        };
    } else {
        return function (selection) {
            return selection;
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    _chart.redrawBrush = function (g, doTransition) {
if (_brushOn) {
    if (_chart.filter() &#x26;&#x26; _chart.brush().empty()) {
        _chart.brush().extent(_chart.filter());
    }

    var gBrush = dc.<span class="apidocCodeKeywordSpan">optionalTransition</span>(doTransition, _chart.transitionDuration(), _chart
.transitionDelay())(g.select(&#x27;g.brush&#x27;));
    _chart.setBrushY(gBrush);
    gBrush.call(_chart.brush()
              .x(_chart.x())
              .extent(_chart.brush().extent()));
}

_chart.fadeDeselectedArea();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.override" id="apidoc.element.dc.dc.override">
        function <span class="apidocSignatureSpan">dc.dc.</span>override
        <span class="apidocSignatureSpan">(obj, functionName, newFunction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">override = function (obj, functionName, newFunction) {
    var existingFunction = obj[functionName];
    obj[&#x27;_&#x27; + functionName] = existingFunction;
    obj[functionName] = newFunction;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!arguments.length) {
    return _outerRangeBandPadding;
}
_outerRangeBandPadding = _;
return _chart;
    };

    dc.<span class="apidocCodeKeywordSpan">override</span>(_chart, &#x27;filter&#x27;, function (_) {
if (!arguments.length) {
    return _chart._filter();
}

_chart._filter(_);

if (_) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.pieChart" id="apidoc.element.dc.dc.pieChart">
        function <span class="apidocSignatureSpan">dc.dc.</span>pieChart
        <span class="apidocSignatureSpan">(parent, chartGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pieChart = function (parent, chartGroup) {
    var DEFAULT_MIN_ANGLE_FOR_LABEL = 0.5;

    var _sliceCssClass = &#x27;pie-slice&#x27;;
    var _labelCssClass = &#x27;pie-label&#x27;;
    var _sliceGroupCssClass = &#x27;pie-slice-group&#x27;;
    var _labelGroupCssClass = &#x27;pie-label-group&#x27;;
    var _emptyCssClass = &#x27;empty-chart&#x27;;
    var _emptyTitle = &#x27;empty&#x27;;

    var _radius,
        _givenRadius, // specified radius, if any
        _innerRadius = 0,
        _externalRadiusPadding = 0;

    var _g;
    var _cx;
    var _cy;
    var _minAngleForLabel = DEFAULT_MIN_ANGLE_FOR_LABEL;
    var _externalLabelRadius;
    var _drawPaths = false;
    var _chart = dc.capMixin(dc.colorMixin(dc.baseMixin({})));

    _chart.colorAccessor(_chart.cappedKeyAccessor);

    _chart.title(function (d) {
        return _chart.cappedKeyAccessor(d) + &#x27;: &#x27; + _chart.cappedValueAccessor(d);
    });

<span class="apidocCodeCommentSpan">    /**
     * Get or set the maximum number of slices the pie chart will generate. The top slices are determined by
     * value from high to low. Other slices exeeding the cap will be rolled up into one single *Others* slice.
     * @method slicesCap
     * @memberof dc.pieChart
     * @instance
     * @param {Number} [cap]
     * @returns {Number|dc.pieChart}
     */
</span>    _chart.slicesCap = _chart.cap;

    _chart.label(_chart.cappedKeyAccessor);
    _chart.renderLabel(true);

    _chart.transitionDuration(350);
    _chart.transitionDelay(0);

    _chart._doRender = function () {
        _chart.resetSvg();

        _g = _chart.svg()
            .append(&#x27;g&#x27;)
            .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + _chart.cx() + &#x27;,&#x27; + _chart.cy() + &#x27;)&#x27;);

        _g.append(&#x27;g&#x27;).attr(&#x27;class&#x27;, _sliceGroupCssClass);
        _g.append(&#x27;g&#x27;).attr(&#x27;class&#x27;, _labelGroupCssClass);

        drawChart();

        return _chart;
    };

    function drawChart () {
        // set radius on basis of chart dimension if missing
        _radius = _givenRadius ? _givenRadius : d3.min([_chart.width(), _chart.height()]) / 2;

        var arc = buildArcs();

        var pie = pieLayout();
        var pieData;
        // if we have data...
        if (d3.sum(_chart.data(), _chart.valueAccessor())) {
            pieData = pie(_chart.data());
            _g.classed(_emptyCssClass, false);
        } else {
            // otherwise we&#x27;d be getting NaNs, so override
            // note: abuse others for its ignoring the value accessor
            pieData = pie([{key: _emptyTitle, value: 1, others: [_emptyTitle]}]);
            _g.classed(_emptyCssClass, true);
        }

        if (_g) {
            var slices = _g.select(&#x27;g.&#x27; + _sliceGroupCssClass)
                .selectAll(&#x27;g.&#x27; + _sliceCssClass)
                .data(pieData);

            var labels = _g.select(&#x27;g.&#x27; + _labelGroupCssClass)
                .selectAll(&#x27;text.&#x27; + _labelCssClass)
                .data(pieData);

            createElements(slices, labels, arc, pieData);

            updateElements(pieData, arc);

            removeElements(slices, labels);

            highlightFilter();

            dc.transition(_g, _chart.transitionDuration(), _chart.transitionDelay())
                .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + _chart.cx() + &#x27;,&#x27; + _chart.cy() + &#x27;)&#x27;);
        }
    }

    function createElements (slices, labels, arc, pieData) {
        var slicesEnter = createSliceNodes(slices);

        createSlicePath(slicesEnter, arc);

        createTitles(slicesEnter);

        createLabels(labels, pieData, arc);
    }

    function createSliceNodes (slices) {
        var slicesEnter = slices
            .enter()
            .append(&#x27;g&#x27;)
            .attr(&#x27;class&#x27;, function (d, i) {
                return _sliceCssClass + &#x27; _&#x27; + i;
            });
        return slicesEnter;
    }

    function createSlicePath (slicesEnter, arc) {
        var slicePath = slicesEnter.append(&#x27;path&#x27;)
            .attr(&#x27;fill&#x27;, fill)
            .on(&#x27;click&#x27;, onClick)
            .attr(&#x27;d&#x27;, function (d, i) {
                return safeArc(d, i, arc);
            });

        var transition = dc.transition(slicePath, _chart.transitionDuration(), _chart.transitionDelay());
        if (transiti ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @class pieChart
* @memberof dc
* @mixes dc.capMixin
* @mixes dc.colorMixin
* @mixes dc.baseMixin
* @example
* // create a pie chart under #chart-container1 element using the default global chart group
* var chart1 = dc.<span class="apidocCodeKeywordSpan">pieChart</span>(&#x27;#chart-container1&#x27;);
* // create a pie chart under #chart-container2 element using chart group A
* var chart2 = dc.pieChart(&#x27;#chart-container2&#x27;, &#x27;chartGroupA&#x27;);
* @param {String|node|d3.selection} parent - Any valid
* {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying
* a dom block element such as a div; or a dom element or d3 selection.
* @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
* Interaction with a chart will only trigger events and redraws within the chart&#x27;s group.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.pluck" id="apidoc.element.dc.dc.pluck">
        function <span class="apidocSignatureSpan">dc.dc.</span>pluck
        <span class="apidocSignatureSpan">(n, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pluck = function (n, f) {
    if (!f) {
        return function (d) { return d[n]; };
    }
    return function (d, i) { return f.call(d, d[n], i); };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Returns a function that given a string property name, can be used to pluck the property off an object.  A function
* can be passed as the second argument to also alter the data being returned.
*
* This can be a useful shorthand method to create accessor functions.
* @method pluck
* @memberof dc
* @example
* var xPluck = dc.<span class="apidocCodeKeywordSpan">pluck</span>(&#x27;x&#x27;);
* var objA = {x: 1};
* xPluck(objA) // 1
* @example
* var xPosition = dc.pluck(&#x27;x&#x27;, function (x, i) {
*     // `this` is the original datum,
*     // `x` is the x property of the datum,
*     // `i` is the position in the array
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.redrawAll" id="apidoc.element.dc.dc.redrawAll">
        function <span class="apidocSignatureSpan">dc.dc.</span>redrawAll
        <span class="apidocSignatureSpan">(group)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redrawAll = function (group) {
    var charts = dc.chartRegistry.list(group);
    for (var i = 0; i &#x3c; charts.length; ++i) {
        charts[i].redraw();
    }

    if (dc._renderlet !== null) {
        dc._renderlet(group);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_chart.redrawGroup = function () {
    if (_commitHandler) {
        _commitHandler(false, function (error, result) {
            if (error) {
                console.log(error);
            } else {
                dc.<span class="apidocCodeKeywordSpan">redrawAll</span>(_chart.chartGroup());
            }
        });
    } else {
        dc.redrawAll(_chart.chartGroup());
    }
    return _chart;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.refocusAll" id="apidoc.element.dc.dc.refocusAll">
        function <span class="apidocSignatureSpan">dc.dc.</span>refocusAll
        <span class="apidocSignatureSpan">(group)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refocusAll = function (group) {
    var charts = dc.chartRegistry.list(group);
    for (var i = 0; i &#x3c; charts.length; ++i) {
        if (charts[i].focus) {
            charts[i].focus();
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.registerChart" id="apidoc.element.dc.dc.registerChart">
        function <span class="apidocSignatureSpan">dc.dc.</span>registerChart
        <span class="apidocSignatureSpan">(chart, group)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerChart = function (chart, group) {
    dc.chartRegistry.register(chart, group);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (parent.select &#x26;&#x26; parent.classed) { // detect d3 selection
            _anchor = parent.node();
        } else {
            _anchor = parent;
        }
        _root = d3.select(_anchor);
        _root.classed(dc.constants.CHART_CLASS, true);
        dc.<span class="apidocCodeKeywordSpan">registerChart</span>(_chart, chartGroup);
        _isChild = false;
    } else {
        throw new dc.errors.BadArgumentException(&#x27;parent must be defined&#x27;);
    }
    _chartGroup = chartGroup;
    return _chart;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.renderAll" id="apidoc.element.dc.dc.renderAll">
        function <span class="apidocSignatureSpan">dc.dc.</span>renderAll
        <span class="apidocSignatureSpan">(group)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderAll = function (group) {
    var charts = dc.chartRegistry.list(group);
    for (var i = 0; i &#x3c; charts.length; ++i) {
        charts[i].render();
    }

    if (dc._renderlet !== null) {
        dc._renderlet(group);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_chart.renderGroup = function () {
    if (_commitHandler) {
        _commitHandler(false, function (error, result) {
            if (error) {
                console.log(error);
            } else {
                dc.<span class="apidocCodeKeywordSpan">renderAll</span>(_chart.chartGroup());
            }
        });
    } else {
        dc.renderAll(_chart.chartGroup());
    }
    return _chart;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.renderlet" id="apidoc.element.dc.dc.renderlet">
        function <span class="apidocSignatureSpan">dc.dc.</span>renderlet
        <span class="apidocSignatureSpan">(_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderlet = function (_) {
    if (!arguments.length) {
        return dc._renderlet;
    }
    dc._renderlet = _;
    return dc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

_chart._activateRenderlets = function (event) {
    _listeners.pretransition(_chart);
    if (_chart.transitionDuration() &#x3e; 0 &#x26;&#x26; _svg) {
        _svg.transition().duration(_chart.transitionDuration()).delay(_chart.transitionDelay())
            .each(&#x27;end&#x27;, function () {
                _listeners.<span class="apidocCodeKeywordSpan">renderlet</span>(_chart);
                if (event) {
                    _listeners[event](_chart);
                }
            });
    } else {
        _listeners.renderlet(_chart);
        if (event) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.rowChart" id="apidoc.element.dc.dc.rowChart">
        function <span class="apidocSignatureSpan">dc.dc.</span>rowChart
        <span class="apidocSignatureSpan">(parent, chartGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rowChart = function (parent, chartGroup) {

    var _g;

    var _labelOffsetX = 10;
    var _labelOffsetY = 15;
    var _hasLabelOffsetY = false;
    var _dyOffset = &#x27;0.35em&#x27;;  // this helps center labels https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#
svg_text
    var _titleLabelOffsetX = 2;

    var _gap = 5;

    var _fixedBarHeight = false;
    var _rowCssClass = &#x27;row&#x27;;
    var _titleRowCssClass = &#x27;titlerow&#x27;;
    var _renderTitleLabel = false;

    var _chart = dc.capMixin(dc.marginMixin(dc.colorMixin(dc.baseMixin({}))));

    var _x;

    var _elasticX;

    var _xAxis = d3.svg.axis().orient(&#x27;bottom&#x27;);

    var _rowData;

    _chart.rowsCap = _chart.cap;

    function calculateAxisScale () {
        if (!_x || _elasticX) {
            var extent = d3.extent(_rowData, _chart.cappedValueAccessor);
            if (extent[0] &#x3e; 0) {
                extent[0] = 0;
            }
            if (extent[1] &#x3c; 0) {
                extent[1] = 0;
            }
            _x = d3.scale.linear().domain(extent)
                .range([0, _chart.effectiveWidth()]);
        }
        _xAxis.scale(_x);
    }

    function drawAxis () {
        var axisG = _g.select(&#x27;g.axis&#x27;);

        calculateAxisScale();

        if (axisG.empty()) {
            axisG = _g.append(&#x27;g&#x27;).attr(&#x27;class&#x27;, &#x27;axis&#x27;);
        }
        axisG.attr(&#x27;transform&#x27;, &#x27;translate(0, &#x27; + _chart.effectiveHeight() + &#x27;)&#x27;);

        dc.transition(axisG, _chart.transitionDuration(), _chart.transitionDelay())
            .call(_xAxis);
    }

    _chart._doRender = function () {
        _chart.resetSvg();

        _g = _chart.svg()
            .append(&#x27;g&#x27;)
            .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + _chart.margins().left + &#x27;,&#x27; + _chart.margins().top + &#x27;)&#x27;);

        drawChart();

        return _chart;
    };

    _chart.title(function (d) {
        return _chart.cappedKeyAccessor(d) + &#x27;: &#x27; + _chart.cappedValueAccessor(d);
    });

    _chart.label(_chart.cappedKeyAccessor);

<span class="apidocCodeCommentSpan">    /**
     * Gets or sets the x scale. The x scale can be any d3
     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Quantitative-Scales.md quantitive scale}.
     * @method x
     * @memberof dc.rowChart
     * @instance
     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Quantitative-Scales.md quantitive scale}
     * @param {d3.scale} [scale]
     * @returns {d3.scale|dc.rowChart}
     */
</span>    _chart.x = function (scale) {
        if (!arguments.length) {
            return _x;
        }
        _x = scale;
        return _chart;
    };

    function drawGridLines () {
        _g.selectAll(&#x27;g.tick&#x27;)
            .select(&#x27;line.grid-line&#x27;)
            .remove();

        _g.selectAll(&#x27;g.tick&#x27;)
            .append(&#x27;line&#x27;)
            .attr(&#x27;class&#x27;, &#x27;grid-line&#x27;)
            .attr(&#x27;x1&#x27;, 0)
            .attr(&#x27;y1&#x27;, 0)
            .attr(&#x27;x2&#x27;, 0)
            .attr(&#x27;y2&#x27;, function () {
                return -_chart.effectiveHeight();
            });
    }

    function drawChart () {
        _rowData = _chart.data();

        drawAxis();
        drawGridLines();

        var rows = _g.selectAll(&#x27;g.&#x27; + _rowCssClass)
            .data(_rowData);

        createElements(rows);
        removeElements(rows);
        updateElements(rows);
    }

    function createElements (rows) {
        var rowEnter = rows.enter()
            .append(&#x27;g&#x27;)
            .attr(&#x27;class&#x27;, function (d, i) {
                return _rowCssClass + &#x27; _&#x27; + i;
            });

        rowEnter.append(&#x27;rect&#x27;).attr(&#x27;width&#x27;, 0);

        createLabels(rowEnter);
    }

    function removeElements (rows) {
        rows.exit().remove();
    }

    function rootValue () {
        var root = _x(0);
        return (root === -Infinity || root !== root) ? _x(1) : root;
    }

    function updateElements (rows) {
        var n = _rowData.length;

        var height;
        if (!_fixedBarHeight) {
            height = (_chart.effectiveHeight() - (n + 1) * _gap) / n;
        } else {
            height = _fixedBarHeight;
        }

        // vertically align label in center unless they override the valu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @memberof dc
* @mixes dc.capMixin
* @mixes dc.marginMixin
* @mixes dc.colorMixin
* @mixes dc.baseMixin
* @example
* // create a row chart under #chart-container1 element using the default global chart group
* var chart1 = dc.<span class="apidocCodeKeywordSpan">rowChart</span>(&#x27;#chart-container1&#x27;);
* // create a row chart under #chart-container2 element using chart group A
* var chart2 = dc.rowChart(&#x27;#chart-container2&#x27;, &#x27;chartGroupA&#x27;);
* @param {String|node|d3.selection} parent - Any valid
* {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying
* a dom block element such as a div; or a dom element or d3 selection.
* @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
* Interaction with a chart will only trigger events and redraws within the chart&#x27;s group.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.scatterPlot" id="apidoc.element.dc.dc.scatterPlot">
        function <span class="apidocSignatureSpan">dc.dc.</span>scatterPlot
        <span class="apidocSignatureSpan">(parent, chartGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scatterPlot = function (parent, chartGroup) {
    var _chart = dc.coordinateGridMixin({});
    var _symbol = d3.svg.symbol();

    var _existenceAccessor = function (d) { return d.value; };

    var originalKeyAccessor = _chart.keyAccessor();
    _chart.keyAccessor(function (d) { return originalKeyAccessor(d)[0]; });
    _chart.valueAccessor(function (d) { return originalKeyAccessor(d)[1]; });
    _chart.colorAccessor(function () { return _chart._groupName; });

    _chart.title(function (d) {
        // this basically just counteracts the setting of its own key/value accessors
        // see https://github.com/dc-js/dc.js/issues/702
        return _chart.keyAccessor()(d) + &#x27;,&#x27; + _chart.valueAccessor()(d) + &#x27;: &#x27; +
            _chart.existenceAccessor()(d);
    });

    var _locator = function (d) {
        return &#x27;translate(&#x27; + _chart.x()(_chart.keyAccessor()(d)) + &#x27;,&#x27; +
                              _chart.y()(_chart.valueAccessor()(d)) + &#x27;)&#x27;;
    };

    var _highlightedSize = 7;
    var _symbolSize = 5;
    var _excludedSize = 3;
    var _excludedColor = null;
    var _excludedOpacity = 1.0;
    var _emptySize = 0;
    var _emptyOpacity = 0;
    var _nonemptyOpacity = 1;
    var _emptyColor = null;
    var _filtered = [];

    _symbol.size(function (d, i) {
        if (!_existenceAccessor(d)) {
            return Math.pow(_emptySize, 2);
        } else if (_filtered[i]) {
            return Math.pow(_symbolSize, 2);
        } else {
            return Math.pow(_excludedSize, 2);
        }
    });

    dc.override(_chart, &#x27;_filter&#x27;, function (filter) {
        if (!arguments.length) {
            return _chart.__filter();
        }

        return _chart.__filter(dc.filters.RangedTwoDimensionalFilter(filter));
    });

    _chart.plotData = function () {
        var symbols = _chart.chartBodyG().selectAll(&#x27;path.symbol&#x27;)
            .data(_chart.data());

        symbols
            .enter()
        .append(&#x27;path&#x27;)
            .attr(&#x27;class&#x27;, &#x27;symbol&#x27;)
            .attr(&#x27;opacity&#x27;, 0)
            .attr(&#x27;fill&#x27;, _chart.getColor)
            .attr(&#x27;transform&#x27;, _locator);

        symbols.call(renderTitles, _chart.data());

        symbols.each(function (d, i) {
            _filtered[i] = !_chart.filter() || _chart.filter().isFiltered([d.key[0], d.key[1]]);
        });

        dc.transition(symbols, _chart.transitionDuration(), _chart.transitionDelay())
            .attr(&#x27;opacity&#x27;, function (d, i) {
                if (!_existenceAccessor(d)) {
                    return _emptyOpacity;
                } else if (_filtered[i]) {
                    return _nonemptyOpacity;
                } else {
                    return _chart.excludedOpacity();
                }
            })
            .attr(&#x27;fill&#x27;, function (d, i) {
                if (_emptyColor &#x26;&#x26; !_existenceAccessor(d)) {
                    return _emptyColor;
                } else if (_chart.excludedColor() &#x26;&#x26; !_filtered[i]) {
                    return _chart.excludedColor();
                } else {
                    return _chart.getColor(d);
                }
            })
            .attr(&#x27;transform&#x27;, _locator)
            .attr(&#x27;d&#x27;, _symbol);

        dc.transition(symbols.exit(), _chart.transitionDuration(), _chart.transitionDelay())
            .attr(&#x27;opacity&#x27;, 0).remove();
    };

    function renderTitles (symbol, d) {
        if (_chart.renderTitle()) {
            symbol.selectAll(&#x27;title&#x27;).remove();
            symbol.append(&#x27;title&#x27;).text(function (d) {
                return _chart.title()(d);
            });
        }
    }

    /**
     * Get or set the existence accessor.  If a point exists, it is drawn with
     * {@link dc.scatterPlot#symbolSize symbolSize} radius and
     * opacity 1; if it does not exist, it is drawn with
     * {@link dc.scatterPlot#emptySize emptySize} radius and opacity 0. By default,
     * the existence accessor checks if the reduced value is truthy.
     * @method existenceAccessor
     * @memberof dc.scatterPlot
     * @instance
     * @see {@link dc.scatterPlot#symbolSize symbolSize}
     * @see {@link dc.scatterPlot#emptySiz ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* - {@link http://dc-js.github.io/dc.js/examples/scatter.html Scatter Chart}
* - {@link http://dc-js.github.io/dc.js/examples/multi-scatter.html Multi-Scatter Chart}
* @class scatterPlot
* @memberof dc
* @mixes dc.coordinateGridMixin
* @example
* // create a scatter plot under #chart-container1 element using the default global chart group
* var chart1 = dc.<span class="apidocCodeKeywordSpan">scatterPlot</span>(&#x27;#chart-container1&#x27;);
* // create a scatter plot under #chart-container2 element using chart group A
* var chart2 = dc.scatterPlot(&#x27;#chart-container2&#x27;, &#x27;chartGroupA&#x27;);
* // create a sub-chart under a composite parent chart
* var chart3 = dc.scatterPlot(compositeChart);
* @param {String|node|d3.selection} parent - Any valid
* {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying
* a dom block element such as a div; or a dom element or d3 selection.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.seriesChart" id="apidoc.element.dc.dc.seriesChart">
        function <span class="apidocSignatureSpan">dc.dc.</span>seriesChart
        <span class="apidocSignatureSpan">(parent, chartGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seriesChart = function (parent, chartGroup) {
    var _chart = dc.compositeChart(parent, chartGroup);

    function keySort (a, b) {
        return d3.ascending(_chart.keyAccessor()(a), _chart.keyAccessor()(b));
    }

    var _charts = {};
    var _chartFunction = dc.lineChart;
    var _seriesAccessor;
    var _seriesSort = d3.ascending;
    var _valueSort = keySort;

    _chart._mandatoryAttributes().push(&#x27;seriesAccessor&#x27;, &#x27;chart&#x27;);
    _chart.shareColors(true);

    _chart._preprocessData = function () {
        var keep = [];
        var childrenChanged;
        var nester = d3.nest().key(_seriesAccessor);
        if (_seriesSort) {
            nester.sortKeys(_seriesSort);
        }
        if (_valueSort) {
            nester.sortValues(_valueSort);
        }
        var nesting = nester.entries(_chart.data());
        var children =
            nesting.map(function (sub, i) {
                var subChart = _charts[sub.key] || _chartFunction.call(_chart, _chart, chartGroup, sub.key, i);
                if (!_charts[sub.key]) {
                    childrenChanged = true;
                }
                _charts[sub.key] = subChart;
                keep.push(sub.key);
                return subChart
                    .dimension(_chart.dimension())
                    .group({all: d3.functor(sub.values)}, sub.key)
                    .keyAccessor(_chart.keyAccessor())
                    .valueAccessor(_chart.valueAccessor())
                    .brushOn(_chart.brushOn());
            });
        // this works around the fact compositeChart doesn&#x27;t really
        // have a removal interface
        Object.keys(_charts)
            .filter(function (c) {return keep.indexOf(c) === -1;})
            .forEach(function (c) {
                clearChart(c);
                childrenChanged = true;
            });
        _chart._compose(children);
        if (childrenChanged &#x26;&#x26; _chart.legend()) {
            _chart.legend().render();
        }
    };

    function clearChart (c) {
        if (_charts[c].g()) {
            _charts[c].g().remove();
        }
        delete _charts[c];
    }

    function resetChildren () {
        Object.keys(_charts).map(clearChart);
        _charts = {};
    }

<span class="apidocCodeCommentSpan">    /**
     * Get or set the chart function, which generates the child charts.
     * @method chart
     * @memberof dc.seriesChart
     * @instance
     * @example
     * // put interpolation on the line charts used for the series
     * chart.chart(function(c) { return dc.lineChart(c).interpolate(&#x27;basis&#x27;); })
     * // do a scatter series chart
     * chart.chart(dc.scatterPlot)
     * @param {Function} [chartFunction=dc.lineChart]
     * @returns {Function|dc.seriesChart}
     */
</span>    _chart.chart = function (chartFunction) {
        if (!arguments.length) {
            return _chartFunction;
        }
        _chartFunction = chartFunction;
        resetChildren();
        return _chart;
    };

    /**
     * **mandatory**
     *
     * Get or set accessor function for the displayed series. Given a datum, this function
     * should return the series that datum belongs to.
     * @method seriesAccessor
     * @memberof dc.seriesChart
     * @instance
     * @example
     * // simple series accessor
     * chart.seriesAccessor(function(d) { return &#x22;Expt: &#x22; + d.key[0]; })
     * @param {Function} [accessor]
     * @returns {Function|dc.seriesChart}
     */
    _chart.seriesAccessor = function (accessor) {
        if (!arguments.length) {
            return _seriesAccessor;
        }
        _seriesAccessor = accessor;
        resetChildren();
        return _chart;
    };

    /**
     * Get or set a function to sort the list of series by, given series values.
     * @method seriesSort
     * @memberof dc.seriesChart
     * @instance
     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_ascending d3.ascending}
     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_descending d3.descending}
     * @example
     * chart.seriesSort(d3.descending);
     * @param {Function} [sortFunct ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Examples:
* - {@link http://dc-js.github.io/dc.js/examples/series.html Series Chart}
* @class seriesChart
* @memberof dc
* @mixes dc.compositeChart
* @example
* // create a series chart under #chart-container1 element using the default global chart group
* var seriesChart1 = dc.<span class="apidocCodeKeywordSpan">seriesChart</span>(&#x22;#chart-container1&#x22;);
* // create a series chart under #chart-container2 element using chart group A
* var seriesChart2 = dc.seriesChart(&#x22;#chart-container2&#x22;, &#x22;chartGroupA&#x22;);
* @param {String|node|d3.selection} parent - Any valid
* {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying
* a dom block element such as a div; or a dom element or d3 selection.
* @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
* Interaction with a chart will only trigger events and redraws within the chart&#x27;s group.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.stackMixin" id="apidoc.element.dc.dc.stackMixin">
        function <span class="apidocSignatureSpan">dc.dc.</span>stackMixin
        <span class="apidocSignatureSpan">(_chart)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stackMixin = function (_chart) {

    function prepareValues (layer, layerIdx) {
        var valAccessor = layer.accessor || _chart.valueAccessor();
        layer.name = String(layer.name || layerIdx);
        layer.values = layer.group.all().map(function (d, i) {
            return {
                x: _chart.keyAccessor()(d, i),
                y: layer.hidden ? null : valAccessor(d, i),
                data: d,
                layer: layer.name,
                hidden: layer.hidden
            };
        });

        layer.values = layer.values.filter(domainFilter());
        return layer.values;
    }

    var _stackLayout = d3.layout.stack()
        .values(prepareValues);

    var _stack = [];
    var _titles = {};

    var _hidableStacks = false;

    function domainFilter () {
        if (!_chart.x()) {
            return d3.functor(true);
        }
        var xDomain = _chart.x().domain();
        if (_chart.isOrdinal()) {
            // TODO #416
            //var domainSet = d3.set(xDomain);
            return function () {
                return true; //domainSet.has(p.x);
            };
        }
        if (_chart.elasticX()) {
            return function () { return true; };
        }
        return function (p) {
            //return true;
            return p.x &#x3e;= xDomain[0] &#x26;&#x26; p.x &#x3c;= xDomain[xDomain.length - 1];
        };
    }

<span class="apidocCodeCommentSpan">    /**
     * Stack a new crossfilter group onto this chart with an optional custom value accessor. All stacks
     * in the same chart will share the same key accessor and therefore the same set of keys.
     *
     * For example, in a stacked bar chart, the bars of each stack will be positioned using the same set
     * of keys on the x axis, while stacked vertically. If name is specified then it will be used to
     * generate the legend label.
     * @method stack
     * @memberof dc.stackMixin
     * @instance
     * @see {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group-map-reduce crossfilter.group}
     * @example
     * // stack group using default accessor
     * chart.stack(valueSumGroup)
     * // stack group using custom accessor
     * .stack(avgByDayGroup, function(d){return d.value.avgByDay;});
     * @param {crossfilter.group} group
     * @param {String} [name]
     * @param {Function} [accessor]
     * @returns {Array&#x3c;{group: crossfilter.group, name: String, accessor: Function}&#x3e;|dc.stackMixin}
     */
</span>    _chart.stack = function (group, name, accessor) {
        if (!arguments.length) {
            return _stack;
        }

        if (arguments.length &#x3c;= 2) {
            accessor = name;
        }

        var layer = {group: group};
        if (typeof name === &#x27;string&#x27;) {
            layer.name = name;
        }
        if (typeof accessor === &#x27;function&#x27;) {
            layer.accessor = accessor;
        }
        _stack.push(layer);

        return _chart;
    };

    dc.override(_chart, &#x27;group&#x27;, function (g, n, f) {
        if (!arguments.length) {
            return _chart._group();
        }
        _stack = [];
        _titles = {};
        _chart.stack(g, n);
        if (f) {
            _chart.valueAccessor(f);
        }
        return _chart._group(g, n);
    });

    /**
     * Allow named stacks to be hidden or shown by clicking on legend items.
     * This does not affect the behavior of hideStack or showStack.
     * @method hidableStacks
     * @memberof dc.stackMixin
     * @instance
     * @param {Boolean} [hidableStacks=false]
     * @returns {Boolean|dc.stackMixin}
     */
    _chart.hidableStacks = function (hidableStacks) {
        if (!arguments.length) {
            return _hidableStacks;
        }
        _hidableStacks = hidableStacks;
        return _chart;
    };

    function findLayerByName (n) {
        var i = _stack.map(dc.pluck(&#x27;name&#x27;)).indexOf(n);
        return _stack[i];
    }

    /**
     * Hide all stacks on the chart with the given name.
     * The chart must be re-rendered for this change to appear.
     * @method hideStack
     * @memberof dc.stackMixin
     * @instance
     * @param {String} stackName ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {dc.barChart}
 */
dc.barChart = function (parent, chartGroup) {
var MIN_BAR_WIDTH = 1;
var DEFAULT_GAP_BETWEEN_BARS = 2;
var LABEL_PADDING = 3;

var _chart = dc.<span class="apidocCodeKeywordSpan">stackMixin</span>(dc.coordinateGridMixin({}));

var _gap = DEFAULT_GAP_BETWEEN_BARS;
var _centerBar = false;
var _alwaysUseRounding = false;

var _barWidth;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.stackableChart" id="apidoc.element.dc.dc.stackableChart">
        function <span class="apidocSignatureSpan">dc.dc.</span>stackableChart
        <span class="apidocSignatureSpan">(_chart)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stackableChart = function (_chart) {

    function prepareValues (layer, layerIdx) {
        var valAccessor = layer.accessor || _chart.valueAccessor();
        layer.name = String(layer.name || layerIdx);
        layer.values = layer.group.all().map(function (d, i) {
            return {
                x: _chart.keyAccessor()(d, i),
                y: layer.hidden ? null : valAccessor(d, i),
                data: d,
                layer: layer.name,
                hidden: layer.hidden
            };
        });

        layer.values = layer.values.filter(domainFilter());
        return layer.values;
    }

    var _stackLayout = d3.layout.stack()
        .values(prepareValues);

    var _stack = [];
    var _titles = {};

    var _hidableStacks = false;

    function domainFilter () {
        if (!_chart.x()) {
            return d3.functor(true);
        }
        var xDomain = _chart.x().domain();
        if (_chart.isOrdinal()) {
            // TODO #416
            //var domainSet = d3.set(xDomain);
            return function () {
                return true; //domainSet.has(p.x);
            };
        }
        if (_chart.elasticX()) {
            return function () { return true; };
        }
        return function (p) {
            //return true;
            return p.x &#x3e;= xDomain[0] &#x26;&#x26; p.x &#x3c;= xDomain[xDomain.length - 1];
        };
    }

<span class="apidocCodeCommentSpan">    /**
     * Stack a new crossfilter group onto this chart with an optional custom value accessor. All stacks
     * in the same chart will share the same key accessor and therefore the same set of keys.
     *
     * For example, in a stacked bar chart, the bars of each stack will be positioned using the same set
     * of keys on the x axis, while stacked vertically. If name is specified then it will be used to
     * generate the legend label.
     * @method stack
     * @memberof dc.stackMixin
     * @instance
     * @see {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group-map-reduce crossfilter.group}
     * @example
     * // stack group using default accessor
     * chart.stack(valueSumGroup)
     * // stack group using custom accessor
     * .stack(avgByDayGroup, function(d){return d.value.avgByDay;});
     * @param {crossfilter.group} group
     * @param {String} [name]
     * @param {Function} [accessor]
     * @returns {Array&#x3c;{group: crossfilter.group, name: String, accessor: Function}&#x3e;|dc.stackMixin}
     */
</span>    _chart.stack = function (group, name, accessor) {
        if (!arguments.length) {
            return _stack;
        }

        if (arguments.length &#x3c;= 2) {
            accessor = name;
        }

        var layer = {group: group};
        if (typeof name === &#x27;string&#x27;) {
            layer.name = name;
        }
        if (typeof accessor === &#x27;function&#x27;) {
            layer.accessor = accessor;
        }
        _stack.push(layer);

        return _chart;
    };

    dc.override(_chart, &#x27;group&#x27;, function (g, n, f) {
        if (!arguments.length) {
            return _chart._group();
        }
        _stack = [];
        _titles = {};
        _chart.stack(g, n);
        if (f) {
            _chart.valueAccessor(f);
        }
        return _chart._group(g, n);
    });

    /**
     * Allow named stacks to be hidden or shown by clicking on legend items.
     * This does not affect the behavior of hideStack or showStack.
     * @method hidableStacks
     * @memberof dc.stackMixin
     * @instance
     * @param {Boolean} [hidableStacks=false]
     * @returns {Boolean|dc.stackMixin}
     */
    _chart.hidableStacks = function (hidableStacks) {
        if (!arguments.length) {
            return _hidableStacks;
        }
        _hidableStacks = hidableStacks;
        return _chart;
    };

    function findLayerByName (n) {
        var i = _stack.map(dc.pluck(&#x27;name&#x27;)).indexOf(n);
        return _stack[i];
    }

    /**
     * Hide all stacks on the chart with the given name.
     * The chart must be re-rendered for this change to appear.
     * @method hideStack
     * @memberof dc.stackMixin
     * @instance
     * @param {String} stackName ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dc.dc.transition" id="apidoc.element.dc.dc.transition">
        function <span class="apidocSignatureSpan">dc.dc.</span>transition
        <span class="apidocSignatureSpan">(selection, duration, delay, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transition = function (selection, duration, delay, name) {
    if (dc.disableTransitions || duration &#x3c;= 0) {
        return selection;
    }

    var s = selection.transition(name);

    if (duration &#x3e;= 0 || duration !== undefined) {
        s = s.duration(duration);
    }
    if (delay &#x3e;= 0 || delay !== undefined) {
        s = s.delay(delay);
    }

    return s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {d3.transition|d3.selection}
 */
dc.transition = function (selection, duration, delay, name) {
if (dc.disableTransitions || duration &#x3c;= 0) {
    return selection;
}

var s = selection.<span class="apidocCodeKeywordSpan">transition</span>(name);

if (duration &#x3e;= 0 || duration !== undefined) {
    s = s.duration(duration);
}
if (delay &#x3e;= 0 || delay !== undefined) {
    s = s.delay(delay);
}
...</pre></li>
    </ul>




























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.dc.shCore" id="apidoc.module.dc.shCore">module dc.shCore</a></h1>


    <h2>
        <a href="#apidoc.element.dc.shCore.XRegExp" id="apidoc.element.dc.shCore.XRegExp">
        function <span class="apidocSignatureSpan">dc.shCore.</span>XRegExp
        <span class="apidocSignatureSpan">(f, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">XRegExp = function (f, e){var a=[],b=XRegExp.OUTSIDE_CLASS,c=0,d,h;if(XRegExp.isRegExp(f)){if(e!==undefined)throw TypeError(&#x22;can&#x27;t supply flags
 when constructing one RegExp from another&#x22;);return r(f)}if(v)throw Error(&#x22;can&#x27;t call the XRegExp constructor within token definition
 functions&#x22;);e=e||&#x22;&#x22;;for(d={hasNamedCapture:false,captureNames:[],hasFlag:function(g){return e.indexOf(g)&#x3e;-1},setFlag:function(g
){e+=g}};c&#x3c;f.length;)if(h=B(f,c,b,d)){a.push(h.output);c+=h.match[0].length||1}else if(h=n.exec.call(z[b],f.slice(c))){a.push(h[
0]);c+=h[0].length}else{h=f.charAt(c);if(h===&#x22;[&#x22;)b=XRegExp.INSIDE_CLASS;else if(h===&#x22;]&#x22;)b=XRegExp.OUTSIDE_CLASS;a.push(h);c++}a=
RegExp(a.join(&#x22;&#x22;),n.replace.call(e,w,&#x22;&#x22;));a._xregexp={source:f,captureNames:d.hasNamedCapture?d.captureNames:null};return a}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
